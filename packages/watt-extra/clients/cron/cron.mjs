// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}
// The additional parameters you want to pass to the `fetch` instance.
let defaultFetchParams = {}
const defaultJsonType = { 'Content-type': 'application/json; charset=utf-8' }

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./cron-types.d.ts').Cron['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./cron-types.d.ts').Cron['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

/**  @type {import('./cron-types.d.ts').Cron['setDefaultFetchParams']} */
export const setDefaultFetchParams = (fetchParams) => { defaultFetchParams = fetchParams }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _getJobs (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.body.eq', 'where.body.neq', 'where.body.gt', 'where.body.gte', 'where.body.lt', 'where.body.lte', 'where.body.like', 'where.body.ilike', 'where.body.in', 'where.body.nin', 'where.body.contains', 'where.body.contained', 'where.body.overlaps', 'where.callbackUrl.eq', 'where.callbackUrl.neq', 'where.callbackUrl.gt', 'where.callbackUrl.gte', 'where.callbackUrl.lt', 'where.callbackUrl.lte', 'where.callbackUrl.like', 'where.callbackUrl.ilike', 'where.callbackUrl.in', 'where.callbackUrl.nin', 'where.callbackUrl.contains', 'where.callbackUrl.contained', 'where.callbackUrl.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.deletedAt.eq', 'where.deletedAt.neq', 'where.deletedAt.gt', 'where.deletedAt.gte', 'where.deletedAt.lt', 'where.deletedAt.lte', 'where.deletedAt.like', 'where.deletedAt.ilike', 'where.deletedAt.in', 'where.deletedAt.nin', 'where.deletedAt.contains', 'where.deletedAt.contained', 'where.deletedAt.overlaps', 'where.headers.eq', 'where.headers.neq', 'where.headers.gt', 'where.headers.gte', 'where.headers.lt', 'where.headers.lte', 'where.headers.like', 'where.headers.ilike', 'where.headers.in', 'where.headers.nin', 'where.headers.contains', 'where.headers.contained', 'where.headers.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.jobType.eq', 'where.jobType.neq', 'where.jobType.gt', 'where.jobType.gte', 'where.jobType.lt', 'where.jobType.lte', 'where.jobType.like', 'where.jobType.ilike', 'where.jobType.in', 'where.jobType.nin', 'where.jobType.contains', 'where.jobType.contained', 'where.jobType.overlaps', 'where.lastRunAt.eq', 'where.lastRunAt.neq', 'where.lastRunAt.gt', 'where.lastRunAt.gte', 'where.lastRunAt.lt', 'where.lastRunAt.lte', 'where.lastRunAt.like', 'where.lastRunAt.ilike', 'where.lastRunAt.in', 'where.lastRunAt.nin', 'where.lastRunAt.contains', 'where.lastRunAt.contained', 'where.lastRunAt.overlaps', 'where.maxRetries.eq', 'where.maxRetries.neq', 'where.maxRetries.gt', 'where.maxRetries.gte', 'where.maxRetries.lt', 'where.maxRetries.lte', 'where.maxRetries.like', 'where.maxRetries.ilike', 'where.maxRetries.in', 'where.maxRetries.nin', 'where.maxRetries.contains', 'where.maxRetries.contained', 'where.maxRetries.overlaps', 'where.method.eq', 'where.method.neq', 'where.method.gt', 'where.method.gte', 'where.method.lt', 'where.method.lte', 'where.method.like', 'where.method.ilike', 'where.method.in', 'where.method.nin', 'where.method.contains', 'where.method.contained', 'where.method.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.nextRunAt.eq', 'where.nextRunAt.neq', 'where.nextRunAt.gt', 'where.nextRunAt.gte', 'where.nextRunAt.lt', 'where.nextRunAt.lte', 'where.nextRunAt.like', 'where.nextRunAt.ilike', 'where.nextRunAt.in', 'where.nextRunAt.nin', 'where.nextRunAt.contains', 'where.nextRunAt.contained', 'where.nextRunAt.overlaps', 'where.paused.eq', 'where.paused.neq', 'where.paused.gt', 'where.paused.gte', 'where.paused.lt', 'where.paused.lte', 'where.paused.like', 'where.paused.ilike', 'where.paused.in', 'where.paused.nin', 'where.paused.contains', 'where.paused.contained', 'where.paused.overlaps', 'where.protected.eq', 'where.protected.neq', 'where.protected.gt', 'where.protected.gte', 'where.protected.lt', 'where.protected.lte', 'where.protected.like', 'where.protected.ilike', 'where.protected.in', 'where.protected.nin', 'where.protected.contains', 'where.protected.contained', 'where.protected.overlaps', 'where.schedule.eq', 'where.schedule.neq', 'where.schedule.gt', 'where.schedule.gte', 'where.schedule.lt', 'where.schedule.lte', 'where.schedule.like', 'where.schedule.ilike', 'where.schedule.in', 'where.schedule.nin', 'where.schedule.contains', 'where.schedule.contained', 'where.schedule.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.ilike', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.or', 'orderby.applicationId', 'orderby.body', 'orderby.callbackUrl', 'orderby.createdAt', 'orderby.deletedAt', 'orderby.headers', 'orderby.id', 'orderby.jobType', 'orderby.lastRunAt', 'orderby.maxRetries', 'orderby.method', 'orderby.name', 'orderby.nextRunAt', 'orderby.paused', 'orderby.protected', 'orderby.schedule', 'orderby.status', 'orderby.updatedAt']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/jobs/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['getJobs']} */
export const getJobs = async (request) => {
  return await _getJobs(baseUrl, request)
}
async function _createJob (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/jobs/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['createJob']} */
export const createJob = async (request) => {
  return await _createJob(baseUrl, request)
}
async function _updateJobs (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.body.eq', 'where.body.neq', 'where.body.gt', 'where.body.gte', 'where.body.lt', 'where.body.lte', 'where.body.like', 'where.body.ilike', 'where.body.in', 'where.body.nin', 'where.body.contains', 'where.body.contained', 'where.body.overlaps', 'where.callbackUrl.eq', 'where.callbackUrl.neq', 'where.callbackUrl.gt', 'where.callbackUrl.gte', 'where.callbackUrl.lt', 'where.callbackUrl.lte', 'where.callbackUrl.like', 'where.callbackUrl.ilike', 'where.callbackUrl.in', 'where.callbackUrl.nin', 'where.callbackUrl.contains', 'where.callbackUrl.contained', 'where.callbackUrl.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.deletedAt.eq', 'where.deletedAt.neq', 'where.deletedAt.gt', 'where.deletedAt.gte', 'where.deletedAt.lt', 'where.deletedAt.lte', 'where.deletedAt.like', 'where.deletedAt.ilike', 'where.deletedAt.in', 'where.deletedAt.nin', 'where.deletedAt.contains', 'where.deletedAt.contained', 'where.deletedAt.overlaps', 'where.headers.eq', 'where.headers.neq', 'where.headers.gt', 'where.headers.gte', 'where.headers.lt', 'where.headers.lte', 'where.headers.like', 'where.headers.ilike', 'where.headers.in', 'where.headers.nin', 'where.headers.contains', 'where.headers.contained', 'where.headers.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.jobType.eq', 'where.jobType.neq', 'where.jobType.gt', 'where.jobType.gte', 'where.jobType.lt', 'where.jobType.lte', 'where.jobType.like', 'where.jobType.ilike', 'where.jobType.in', 'where.jobType.nin', 'where.jobType.contains', 'where.jobType.contained', 'where.jobType.overlaps', 'where.lastRunAt.eq', 'where.lastRunAt.neq', 'where.lastRunAt.gt', 'where.lastRunAt.gte', 'where.lastRunAt.lt', 'where.lastRunAt.lte', 'where.lastRunAt.like', 'where.lastRunAt.ilike', 'where.lastRunAt.in', 'where.lastRunAt.nin', 'where.lastRunAt.contains', 'where.lastRunAt.contained', 'where.lastRunAt.overlaps', 'where.maxRetries.eq', 'where.maxRetries.neq', 'where.maxRetries.gt', 'where.maxRetries.gte', 'where.maxRetries.lt', 'where.maxRetries.lte', 'where.maxRetries.like', 'where.maxRetries.ilike', 'where.maxRetries.in', 'where.maxRetries.nin', 'where.maxRetries.contains', 'where.maxRetries.contained', 'where.maxRetries.overlaps', 'where.method.eq', 'where.method.neq', 'where.method.gt', 'where.method.gte', 'where.method.lt', 'where.method.lte', 'where.method.like', 'where.method.ilike', 'where.method.in', 'where.method.nin', 'where.method.contains', 'where.method.contained', 'where.method.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.nextRunAt.eq', 'where.nextRunAt.neq', 'where.nextRunAt.gt', 'where.nextRunAt.gte', 'where.nextRunAt.lt', 'where.nextRunAt.lte', 'where.nextRunAt.like', 'where.nextRunAt.ilike', 'where.nextRunAt.in', 'where.nextRunAt.nin', 'where.nextRunAt.contains', 'where.nextRunAt.contained', 'where.nextRunAt.overlaps', 'where.paused.eq', 'where.paused.neq', 'where.paused.gt', 'where.paused.gte', 'where.paused.lt', 'where.paused.lte', 'where.paused.like', 'where.paused.ilike', 'where.paused.in', 'where.paused.nin', 'where.paused.contains', 'where.paused.contained', 'where.paused.overlaps', 'where.protected.eq', 'where.protected.neq', 'where.protected.gt', 'where.protected.gte', 'where.protected.lt', 'where.protected.lte', 'where.protected.like', 'where.protected.ilike', 'where.protected.in', 'where.protected.nin', 'where.protected.contains', 'where.protected.contained', 'where.protected.overlaps', 'where.schedule.eq', 'where.schedule.neq', 'where.schedule.gt', 'where.schedule.gte', 'where.schedule.lt', 'where.schedule.lte', 'where.schedule.like', 'where.schedule.ilike', 'where.schedule.in', 'where.schedule.nin', 'where.schedule.contains', 'where.schedule.contained', 'where.schedule.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.ilike', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/jobs/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['updateJobs']} */
export const updateJobs = async (request) => {
  return await _updateJobs(baseUrl, request)
}
async function _getJobById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/jobs/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['getJobById']} */
export const getJobById = async (request) => {
  return await _getJobById(baseUrl, request)
}
async function _updateJob (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/jobs/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['updateJob']} */
export const updateJob = async (request) => {
  return await _updateJob(baseUrl, request)
}
async function _deleteJobs (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/jobs/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['deleteJobs']} */
export const deleteJobs = async (request) => {
  return await _deleteJobs(baseUrl, request)
}
async function _getMessagesForJob (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/jobs/${request['id']}/messages?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['getMessagesForJob']} */
export const getMessagesForJob = async (request) => {
  return await _getMessagesForJob(baseUrl, request)
}
async function _getMessages (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.body.eq', 'where.body.neq', 'where.body.gt', 'where.body.gte', 'where.body.lt', 'where.body.lte', 'where.body.like', 'where.body.ilike', 'where.body.in', 'where.body.nin', 'where.body.contains', 'where.body.contained', 'where.body.overlaps', 'where.callbackUrl.eq', 'where.callbackUrl.neq', 'where.callbackUrl.gt', 'where.callbackUrl.gte', 'where.callbackUrl.lt', 'where.callbackUrl.lte', 'where.callbackUrl.like', 'where.callbackUrl.ilike', 'where.callbackUrl.in', 'where.callbackUrl.nin', 'where.callbackUrl.contains', 'where.callbackUrl.contained', 'where.callbackUrl.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.deletedAt.eq', 'where.deletedAt.neq', 'where.deletedAt.gt', 'where.deletedAt.gte', 'where.deletedAt.lt', 'where.deletedAt.lte', 'where.deletedAt.like', 'where.deletedAt.ilike', 'where.deletedAt.in', 'where.deletedAt.nin', 'where.deletedAt.contains', 'where.deletedAt.contained', 'where.deletedAt.overlaps', 'where.failed.eq', 'where.failed.neq', 'where.failed.gt', 'where.failed.gte', 'where.failed.lt', 'where.failed.lte', 'where.failed.like', 'where.failed.ilike', 'where.failed.in', 'where.failed.nin', 'where.failed.contains', 'where.failed.contained', 'where.failed.overlaps', 'where.headers.eq', 'where.headers.neq', 'where.headers.gt', 'where.headers.gte', 'where.headers.lt', 'where.headers.lte', 'where.headers.like', 'where.headers.ilike', 'where.headers.in', 'where.headers.nin', 'where.headers.contains', 'where.headers.contained', 'where.headers.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.jobId.eq', 'where.jobId.neq', 'where.jobId.gt', 'where.jobId.gte', 'where.jobId.lt', 'where.jobId.lte', 'where.jobId.like', 'where.jobId.ilike', 'where.jobId.in', 'where.jobId.nin', 'where.jobId.contains', 'where.jobId.contained', 'where.jobId.overlaps', 'where.method.eq', 'where.method.neq', 'where.method.gt', 'where.method.gte', 'where.method.lt', 'where.method.lte', 'where.method.like', 'where.method.ilike', 'where.method.in', 'where.method.nin', 'where.method.contains', 'where.method.contained', 'where.method.overlaps', 'where.noReschedule.eq', 'where.noReschedule.neq', 'where.noReschedule.gt', 'where.noReschedule.gte', 'where.noReschedule.lt', 'where.noReschedule.lte', 'where.noReschedule.like', 'where.noReschedule.ilike', 'where.noReschedule.in', 'where.noReschedule.nin', 'where.noReschedule.contains', 'where.noReschedule.contained', 'where.noReschedule.overlaps', 'where.responseBody.eq', 'where.responseBody.neq', 'where.responseBody.gt', 'where.responseBody.gte', 'where.responseBody.lt', 'where.responseBody.lte', 'where.responseBody.like', 'where.responseBody.ilike', 'where.responseBody.in', 'where.responseBody.nin', 'where.responseBody.contains', 'where.responseBody.contained', 'where.responseBody.overlaps', 'where.responseHeaders.eq', 'where.responseHeaders.neq', 'where.responseHeaders.gt', 'where.responseHeaders.gte', 'where.responseHeaders.lt', 'where.responseHeaders.lte', 'where.responseHeaders.like', 'where.responseHeaders.ilike', 'where.responseHeaders.in', 'where.responseHeaders.nin', 'where.responseHeaders.contains', 'where.responseHeaders.contained', 'where.responseHeaders.overlaps', 'where.responseStatusCode.eq', 'where.responseStatusCode.neq', 'where.responseStatusCode.gt', 'where.responseStatusCode.gte', 'where.responseStatusCode.lt', 'where.responseStatusCode.lte', 'where.responseStatusCode.like', 'where.responseStatusCode.ilike', 'where.responseStatusCode.in', 'where.responseStatusCode.nin', 'where.responseStatusCode.contains', 'where.responseStatusCode.contained', 'where.responseStatusCode.overlaps', 'where.retries.eq', 'where.retries.neq', 'where.retries.gt', 'where.retries.gte', 'where.retries.lt', 'where.retries.lte', 'where.retries.like', 'where.retries.ilike', 'where.retries.in', 'where.retries.nin', 'where.retries.contains', 'where.retries.contained', 'where.retries.overlaps', 'where.sentAt.eq', 'where.sentAt.neq', 'where.sentAt.gt', 'where.sentAt.gte', 'where.sentAt.lt', 'where.sentAt.lte', 'where.sentAt.like', 'where.sentAt.ilike', 'where.sentAt.in', 'where.sentAt.nin', 'where.sentAt.contains', 'where.sentAt.contained', 'where.sentAt.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.when.eq', 'where.when.neq', 'where.when.gt', 'where.when.gte', 'where.when.lt', 'where.when.lte', 'where.when.like', 'where.when.ilike', 'where.when.in', 'where.when.nin', 'where.when.contains', 'where.when.contained', 'where.when.overlaps', 'where.or', 'orderby.body', 'orderby.callbackUrl', 'orderby.createdAt', 'orderby.deletedAt', 'orderby.failed', 'orderby.headers', 'orderby.id', 'orderby.jobId', 'orderby.method', 'orderby.noReschedule', 'orderby.responseBody', 'orderby.responseHeaders', 'orderby.responseStatusCode', 'orderby.retries', 'orderby.sentAt', 'orderby.updatedAt', 'orderby.when']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/messages/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['getMessages']} */
export const getMessages = async (request) => {
  return await _getMessages(baseUrl, request)
}
async function _createMessage (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/messages/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['createMessage']} */
export const createMessage = async (request) => {
  return await _createMessage(baseUrl, request)
}
async function _updateMessages (url, request) {
  const queryParameters = ['fields', 'where.body.eq', 'where.body.neq', 'where.body.gt', 'where.body.gte', 'where.body.lt', 'where.body.lte', 'where.body.like', 'where.body.ilike', 'where.body.in', 'where.body.nin', 'where.body.contains', 'where.body.contained', 'where.body.overlaps', 'where.callbackUrl.eq', 'where.callbackUrl.neq', 'where.callbackUrl.gt', 'where.callbackUrl.gte', 'where.callbackUrl.lt', 'where.callbackUrl.lte', 'where.callbackUrl.like', 'where.callbackUrl.ilike', 'where.callbackUrl.in', 'where.callbackUrl.nin', 'where.callbackUrl.contains', 'where.callbackUrl.contained', 'where.callbackUrl.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.deletedAt.eq', 'where.deletedAt.neq', 'where.deletedAt.gt', 'where.deletedAt.gte', 'where.deletedAt.lt', 'where.deletedAt.lte', 'where.deletedAt.like', 'where.deletedAt.ilike', 'where.deletedAt.in', 'where.deletedAt.nin', 'where.deletedAt.contains', 'where.deletedAt.contained', 'where.deletedAt.overlaps', 'where.failed.eq', 'where.failed.neq', 'where.failed.gt', 'where.failed.gte', 'where.failed.lt', 'where.failed.lte', 'where.failed.like', 'where.failed.ilike', 'where.failed.in', 'where.failed.nin', 'where.failed.contains', 'where.failed.contained', 'where.failed.overlaps', 'where.headers.eq', 'where.headers.neq', 'where.headers.gt', 'where.headers.gte', 'where.headers.lt', 'where.headers.lte', 'where.headers.like', 'where.headers.ilike', 'where.headers.in', 'where.headers.nin', 'where.headers.contains', 'where.headers.contained', 'where.headers.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.jobId.eq', 'where.jobId.neq', 'where.jobId.gt', 'where.jobId.gte', 'where.jobId.lt', 'where.jobId.lte', 'where.jobId.like', 'where.jobId.ilike', 'where.jobId.in', 'where.jobId.nin', 'where.jobId.contains', 'where.jobId.contained', 'where.jobId.overlaps', 'where.method.eq', 'where.method.neq', 'where.method.gt', 'where.method.gte', 'where.method.lt', 'where.method.lte', 'where.method.like', 'where.method.ilike', 'where.method.in', 'where.method.nin', 'where.method.contains', 'where.method.contained', 'where.method.overlaps', 'where.noReschedule.eq', 'where.noReschedule.neq', 'where.noReschedule.gt', 'where.noReschedule.gte', 'where.noReschedule.lt', 'where.noReschedule.lte', 'where.noReschedule.like', 'where.noReschedule.ilike', 'where.noReschedule.in', 'where.noReschedule.nin', 'where.noReschedule.contains', 'where.noReschedule.contained', 'where.noReschedule.overlaps', 'where.responseBody.eq', 'where.responseBody.neq', 'where.responseBody.gt', 'where.responseBody.gte', 'where.responseBody.lt', 'where.responseBody.lte', 'where.responseBody.like', 'where.responseBody.ilike', 'where.responseBody.in', 'where.responseBody.nin', 'where.responseBody.contains', 'where.responseBody.contained', 'where.responseBody.overlaps', 'where.responseHeaders.eq', 'where.responseHeaders.neq', 'where.responseHeaders.gt', 'where.responseHeaders.gte', 'where.responseHeaders.lt', 'where.responseHeaders.lte', 'where.responseHeaders.like', 'where.responseHeaders.ilike', 'where.responseHeaders.in', 'where.responseHeaders.nin', 'where.responseHeaders.contains', 'where.responseHeaders.contained', 'where.responseHeaders.overlaps', 'where.responseStatusCode.eq', 'where.responseStatusCode.neq', 'where.responseStatusCode.gt', 'where.responseStatusCode.gte', 'where.responseStatusCode.lt', 'where.responseStatusCode.lte', 'where.responseStatusCode.like', 'where.responseStatusCode.ilike', 'where.responseStatusCode.in', 'where.responseStatusCode.nin', 'where.responseStatusCode.contains', 'where.responseStatusCode.contained', 'where.responseStatusCode.overlaps', 'where.retries.eq', 'where.retries.neq', 'where.retries.gt', 'where.retries.gte', 'where.retries.lt', 'where.retries.lte', 'where.retries.like', 'where.retries.ilike', 'where.retries.in', 'where.retries.nin', 'where.retries.contains', 'where.retries.contained', 'where.retries.overlaps', 'where.sentAt.eq', 'where.sentAt.neq', 'where.sentAt.gt', 'where.sentAt.gte', 'where.sentAt.lt', 'where.sentAt.lte', 'where.sentAt.like', 'where.sentAt.ilike', 'where.sentAt.in', 'where.sentAt.nin', 'where.sentAt.contains', 'where.sentAt.contained', 'where.sentAt.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.when.eq', 'where.when.neq', 'where.when.gt', 'where.when.gte', 'where.when.lt', 'where.when.lte', 'where.when.like', 'where.when.ilike', 'where.when.in', 'where.when.nin', 'where.when.contains', 'where.when.contained', 'where.when.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/messages/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['updateMessages']} */
export const updateMessages = async (request) => {
  return await _updateMessages(baseUrl, request)
}
async function _getMessageById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/messages/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['getMessageById']} */
export const getMessageById = async (request) => {
  return await _getMessageById(baseUrl, request)
}
async function _updateMessage (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/messages/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['updateMessage']} */
export const updateMessage = async (request) => {
  return await _updateMessage(baseUrl, request)
}
async function _deleteMessages (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/messages/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['deleteMessages']} */
export const deleteMessages = async (request) => {
  return await _deleteMessages(baseUrl, request)
}
async function _getJobForMessage (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/messages/${request['id']}/job?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./cron-types.d.ts').Cron['getJobForMessage']} */
export const getJobForMessage = async (request) => {
  return await _getJobForMessage(baseUrl, request)
}
async function _getIccJobsName (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/icc-jobs/${request['name']}`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['getIccJobsName']} */
export const getIccJobsName = async (request) => {
  return await _getIccJobsName(baseUrl, request)
}
async function _putIccJobsName (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/icc-jobs/${request['name']}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['putIccJobsName']} */
export const putIccJobsName = async (request) => {
  return await _putIccJobsName(baseUrl, request)
}
async function _getIccJobs (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/icc-jobs`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['getIccJobs']} */
export const getIccJobs = async (request) => {
  return await _getIccJobs(baseUrl, request)
}
async function _putIccJobs (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/icc-jobs`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['putIccJobs']} */
export const putIccJobs = async (request) => {
  return await _putIccJobs(baseUrl, request)
}
async function _getJobsIdRun (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/jobs/${request['id']}/run`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['getJobsIdRun']} */
export const getJobsIdRun = async (request) => {
  return await _getJobsIdRun(baseUrl, request)
}
async function _getJobsIdPause (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/jobs/${request['id']}/pause`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['getJobsIdPause']} */
export const getJobsIdPause = async (request) => {
  return await _getJobsIdPause(baseUrl, request)
}
async function _getJobsIdResume (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/jobs/${request['id']}/resume`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['getJobsIdResume']} */
export const getJobsIdResume = async (request) => {
  return await _getJobsIdResume(baseUrl, request)
}
async function _getMessagesIdCancel (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/messages/${request['id']}/cancel`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['getMessagesIdCancel']} */
export const getMessagesIdCancel = async (request) => {
  return await _getMessagesIdCancel(baseUrl, request)
}
async function _putWattJobs (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/watt-jobs`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./cron-types.d.ts').Cron['putWattJobs']} */
export const putWattJobs = async (request) => {
  return await _putWattJobs(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getJobs: _getJobs.bind(url, ...arguments),
    createJob: _createJob.bind(url, ...arguments),
    updateJobs: _updateJobs.bind(url, ...arguments),
    getJobById: _getJobById.bind(url, ...arguments),
    updateJob: _updateJob.bind(url, ...arguments),
    deleteJobs: _deleteJobs.bind(url, ...arguments),
    getMessagesForJob: _getMessagesForJob.bind(url, ...arguments),
    getMessages: _getMessages.bind(url, ...arguments),
    createMessage: _createMessage.bind(url, ...arguments),
    updateMessages: _updateMessages.bind(url, ...arguments),
    getMessageById: _getMessageById.bind(url, ...arguments),
    updateMessage: _updateMessage.bind(url, ...arguments),
    deleteMessages: _deleteMessages.bind(url, ...arguments),
    getJobForMessage: _getJobForMessage.bind(url, ...arguments),
    getIccJobsName: _getIccJobsName.bind(url, ...arguments),
    putIccJobsName: _putIccJobsName.bind(url, ...arguments),
    getIccJobs: _getIccJobs.bind(url, ...arguments),
    putIccJobs: _putIccJobs.bind(url, ...arguments),
    getJobsIdRun: _getJobsIdRun.bind(url, ...arguments),
    getJobsIdPause: _getJobsIdPause.bind(url, ...arguments),
    getJobsIdResume: _getJobsIdResume.bind(url, ...arguments),
    getMessagesIdCancel: _getMessagesIdCancel.bind(url, ...arguments),
    putWattJobs: _putWattJobs.bind(url, ...arguments)
  }
}