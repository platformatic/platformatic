// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./compliance-types.d.ts').Compliance['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./compliance-types.d.ts').Compliance['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _getReports (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.bundleId.eq', 'where.bundleId.neq', 'where.bundleId.gt', 'where.bundleId.gte', 'where.bundleId.lt', 'where.bundleId.lte', 'where.bundleId.like', 'where.bundleId.in', 'where.bundleId.nin', 'where.bundleId.contains', 'where.bundleId.contained', 'where.bundleId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.result.eq', 'where.result.neq', 'where.result.gt', 'where.result.gte', 'where.result.lt', 'where.result.lte', 'where.result.like', 'where.result.in', 'where.result.nin', 'where.result.contains', 'where.result.contained', 'where.result.overlaps', 'where.ruleSet.eq', 'where.ruleSet.neq', 'where.ruleSet.gt', 'where.ruleSet.gte', 'where.ruleSet.lt', 'where.ruleSet.lte', 'where.ruleSet.like', 'where.ruleSet.in', 'where.ruleSet.nin', 'where.ruleSet.contains', 'where.ruleSet.contained', 'where.ruleSet.overlaps', 'where.or', 'orderby.applicationId', 'orderby.bundleId', 'orderby.createdAt', 'orderby.id', 'orderby.result', 'orderby.ruleSet']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/reports/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getReports']} */
export const getReports = async (request) => {
  return await _getReports(baseUrl, request)
}
async function _createReport (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/reports/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['createReport']} */
export const createReport = async (request) => {
  return await _createReport(baseUrl, request)
}
async function _updateReports (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.bundleId.eq', 'where.bundleId.neq', 'where.bundleId.gt', 'where.bundleId.gte', 'where.bundleId.lt', 'where.bundleId.lte', 'where.bundleId.like', 'where.bundleId.in', 'where.bundleId.nin', 'where.bundleId.contains', 'where.bundleId.contained', 'where.bundleId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.result.eq', 'where.result.neq', 'where.result.gt', 'where.result.gte', 'where.result.lt', 'where.result.lte', 'where.result.like', 'where.result.in', 'where.result.nin', 'where.result.contains', 'where.result.contained', 'where.result.overlaps', 'where.ruleSet.eq', 'where.ruleSet.neq', 'where.ruleSet.gt', 'where.ruleSet.gte', 'where.ruleSet.lt', 'where.ruleSet.lte', 'where.ruleSet.like', 'where.ruleSet.in', 'where.ruleSet.nin', 'where.ruleSet.contains', 'where.ruleSet.contained', 'where.ruleSet.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/reports/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateReports']} */
export const updateReports = async (request) => {
  return await _updateReports(baseUrl, request)
}
async function _getReportById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/reports/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getReportById']} */
export const getReportById = async (request) => {
  return await _getReportById(baseUrl, request)
}
async function _updateReport (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/reports/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateReport']} */
export const updateReport = async (request) => {
  return await _updateReport(baseUrl, request)
}
async function _deleteReports (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/reports/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['deleteReports']} */
export const deleteReports = async (request) => {
  return await _deleteReports(baseUrl, request)
}
async function _createRule (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/rules/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['createRule']} */
export const createRule = async (request) => {
  return await _createRule(baseUrl, request)
}
async function _updateRules (url, request) {
  const queryParameters = ['fields', 'where.config.eq', 'where.config.neq', 'where.config.gt', 'where.config.gte', 'where.config.lt', 'where.config.lte', 'where.config.like', 'where.config.in', 'where.config.nin', 'where.config.contains', 'where.config.contained', 'where.config.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.label.eq', 'where.label.neq', 'where.label.gt', 'where.label.gte', 'where.label.lt', 'where.label.lte', 'where.label.like', 'where.label.in', 'where.label.nin', 'where.label.contains', 'where.label.contained', 'where.label.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/rules/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateRules']} */
export const updateRules = async (request) => {
  return await _updateRules(baseUrl, request)
}
async function _getRuleById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/rules/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getRuleById']} */
export const getRuleById = async (request) => {
  return await _getRuleById(baseUrl, request)
}
async function _updateRule (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/rules/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateRule']} */
export const updateRule = async (request) => {
  return await _updateRule(baseUrl, request)
}
async function _deleteRules (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/rules/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['deleteRules']} */
export const deleteRules = async (request) => {
  return await _deleteRules(baseUrl, request)
}
async function _getRuleConfigsForRule (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/rules/${request['id']}/ruleConfigs?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getRuleConfigsForRule']} */
export const getRuleConfigsForRule = async (request) => {
  return await _getRuleConfigsForRule(baseUrl, request)
}
async function _getRuleConfigs (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.enabled.eq', 'where.enabled.neq', 'where.enabled.gt', 'where.enabled.gte', 'where.enabled.lt', 'where.enabled.lte', 'where.enabled.like', 'where.enabled.in', 'where.enabled.nin', 'where.enabled.contains', 'where.enabled.contained', 'where.enabled.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.options.eq', 'where.options.neq', 'where.options.gt', 'where.options.gte', 'where.options.lt', 'where.options.lte', 'where.options.like', 'where.options.in', 'where.options.nin', 'where.options.contains', 'where.options.contained', 'where.options.overlaps', 'where.ruleId.eq', 'where.ruleId.neq', 'where.ruleId.gt', 'where.ruleId.gte', 'where.ruleId.lt', 'where.ruleId.lte', 'where.ruleId.like', 'where.ruleId.in', 'where.ruleId.nin', 'where.ruleId.contains', 'where.ruleId.contained', 'where.ruleId.overlaps', 'where.type.eq', 'where.type.neq', 'where.type.gt', 'where.type.gte', 'where.type.lt', 'where.type.lte', 'where.type.like', 'where.type.in', 'where.type.nin', 'where.type.contains', 'where.type.contained', 'where.type.overlaps', 'where.or', 'orderby.applicationId', 'orderby.createdAt', 'orderby.enabled', 'orderby.id', 'orderby.options', 'orderby.ruleId', 'orderby.type']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/ruleConfigs/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getRuleConfigs']} */
export const getRuleConfigs = async (request) => {
  return await _getRuleConfigs(baseUrl, request)
}
async function _createRuleConfig (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ruleConfigs/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['createRuleConfig']} */
export const createRuleConfig = async (request) => {
  return await _createRuleConfig(baseUrl, request)
}
async function _updateRuleConfigs (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.enabled.eq', 'where.enabled.neq', 'where.enabled.gt', 'where.enabled.gte', 'where.enabled.lt', 'where.enabled.lte', 'where.enabled.like', 'where.enabled.in', 'where.enabled.nin', 'where.enabled.contains', 'where.enabled.contained', 'where.enabled.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.options.eq', 'where.options.neq', 'where.options.gt', 'where.options.gte', 'where.options.lt', 'where.options.lte', 'where.options.like', 'where.options.in', 'where.options.nin', 'where.options.contains', 'where.options.contained', 'where.options.overlaps', 'where.ruleId.eq', 'where.ruleId.neq', 'where.ruleId.gt', 'where.ruleId.gte', 'where.ruleId.lt', 'where.ruleId.lte', 'where.ruleId.like', 'where.ruleId.in', 'where.ruleId.nin', 'where.ruleId.contains', 'where.ruleId.contained', 'where.ruleId.overlaps', 'where.type.eq', 'where.type.neq', 'where.type.gt', 'where.type.gte', 'where.type.lt', 'where.type.lte', 'where.type.like', 'where.type.in', 'where.type.nin', 'where.type.contains', 'where.type.contained', 'where.type.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ruleConfigs/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateRuleConfigs']} */
export const updateRuleConfigs = async (request) => {
  return await _updateRuleConfigs(baseUrl, request)
}
async function _getRuleConfigById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/ruleConfigs/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getRuleConfigById']} */
export const getRuleConfigById = async (request) => {
  return await _getRuleConfigById(baseUrl, request)
}
async function _updateRuleConfig (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ruleConfigs/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateRuleConfig']} */
export const updateRuleConfig = async (request) => {
  return await _updateRuleConfig(baseUrl, request)
}
async function _deleteRuleConfigs (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ruleConfigs/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['deleteRuleConfigs']} */
export const deleteRuleConfigs = async (request) => {
  return await _deleteRuleConfigs(baseUrl, request)
}
async function _getRuleForRuleConfig (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/ruleConfigs/${request['id']}/rule?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getRuleForRuleConfig']} */
export const getRuleForRuleConfig = async (request) => {
  return await _getRuleForRuleConfig(baseUrl, request)
}
async function _getMetadata (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.bundleId.eq', 'where.bundleId.neq', 'where.bundleId.gt', 'where.bundleId.gte', 'where.bundleId.lt', 'where.bundleId.lte', 'where.bundleId.like', 'where.bundleId.in', 'where.bundleId.nin', 'where.bundleId.contains', 'where.bundleId.contained', 'where.bundleId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.data.eq', 'where.data.neq', 'where.data.gt', 'where.data.gte', 'where.data.lt', 'where.data.lte', 'where.data.like', 'where.data.in', 'where.data.nin', 'where.data.contains', 'where.data.contained', 'where.data.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or', 'orderby.applicationId', 'orderby.bundleId', 'orderby.createdAt', 'orderby.data', 'orderby.id']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/metadata/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getMetadata']} */
export const getMetadata = async (request) => {
  return await _getMetadata(baseUrl, request)
}
async function _updateMetadata (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.bundleId.eq', 'where.bundleId.neq', 'where.bundleId.gt', 'where.bundleId.gte', 'where.bundleId.lt', 'where.bundleId.lte', 'where.bundleId.like', 'where.bundleId.in', 'where.bundleId.nin', 'where.bundleId.contains', 'where.bundleId.contained', 'where.bundleId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.data.eq', 'where.data.neq', 'where.data.gt', 'where.data.gte', 'where.data.lt', 'where.data.lte', 'where.data.like', 'where.data.in', 'where.data.nin', 'where.data.contains', 'where.data.contained', 'where.data.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/metadata/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateMetadata']} */
export const updateMetadata = async (request) => {
  return await _updateMetadata(baseUrl, request)
}
async function _getMetadatumById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/metadata/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['getMetadatumById']} */
export const getMetadatumById = async (request) => {
  return await _getMetadatumById(baseUrl, request)
}
async function _updateMetadatum (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/metadata/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['updateMetadatum']} */
export const updateMetadatum = async (request) => {
  return await _updateMetadatum(baseUrl, request)
}
async function _deleteMetadata (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/metadata/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compliance-types.d.ts').Compliance['deleteMetadata']} */
export const deleteMetadata = async (request) => {
  return await _deleteMetadata(baseUrl, request)
}
async function _postCompliance (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/compliance`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./compliance-types.d.ts').Compliance['postCompliance']} */
export const postCompliance = async (request) => {
  return await _postCompliance(baseUrl, request)
}
async function _postMetadata (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/metadata`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./compliance-types.d.ts').Compliance['postMetadata']} */
export const postMetadata = async (request) => {
  return await _postMetadata(baseUrl, request)
}
async function _postRulesName (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/rules/${request['name']}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./compliance-types.d.ts').Compliance['postRulesName']} */
export const postRulesName = async (request) => {
  return await _postRulesName(baseUrl, request)
}
async function _getRules (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/rules`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./compliance-types.d.ts').Compliance['getRules']} */
export const getRules = async (request) => {
  return await _getRules(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getReports: _getReports.bind(url, ...arguments),
    createReport: _createReport.bind(url, ...arguments),
    updateReports: _updateReports.bind(url, ...arguments),
    getReportById: _getReportById.bind(url, ...arguments),
    updateReport: _updateReport.bind(url, ...arguments),
    deleteReports: _deleteReports.bind(url, ...arguments),
    createRule: _createRule.bind(url, ...arguments),
    updateRules: _updateRules.bind(url, ...arguments),
    getRuleById: _getRuleById.bind(url, ...arguments),
    updateRule: _updateRule.bind(url, ...arguments),
    deleteRules: _deleteRules.bind(url, ...arguments),
    getRuleConfigsForRule: _getRuleConfigsForRule.bind(url, ...arguments),
    getRuleConfigs: _getRuleConfigs.bind(url, ...arguments),
    createRuleConfig: _createRuleConfig.bind(url, ...arguments),
    updateRuleConfigs: _updateRuleConfigs.bind(url, ...arguments),
    getRuleConfigById: _getRuleConfigById.bind(url, ...arguments),
    updateRuleConfig: _updateRuleConfig.bind(url, ...arguments),
    deleteRuleConfigs: _deleteRuleConfigs.bind(url, ...arguments),
    getRuleForRuleConfig: _getRuleForRuleConfig.bind(url, ...arguments),
    getMetadata: _getMetadata.bind(url, ...arguments),
    updateMetadata: _updateMetadata.bind(url, ...arguments),
    getMetadatumById: _getMetadatumById.bind(url, ...arguments),
    updateMetadatum: _updateMetadatum.bind(url, ...arguments),
    deleteMetadata: _deleteMetadata.bind(url, ...arguments),
    postCompliance: _postCompliance.bind(url, ...arguments),
    postMetadata: _postMetadata.bind(url, ...arguments),
    postRulesName: _postRulesName.bind(url, ...arguments),
    getRules: _getRules.bind(url, ...arguments)
  }
}