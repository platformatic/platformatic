// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}
// The additional parameters you want to pass to the `fetch` instance.
let defaultFetchParams = {}
const defaultJsonType = { 'Content-type': 'application/json; charset=utf-8' }

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./control-plane-types.d.ts').ControlPlane['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./control-plane-types.d.ts').ControlPlane['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

/**  @type {import('./control-plane-types.d.ts').ControlPlane['setDefaultFetchParams']} */
export const setDefaultFetchParams = (fetchParams) => { defaultFetchParams = fetchParams }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _getGenerations (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.version.eq', 'where.version.neq', 'where.version.gt', 'where.version.gte', 'where.version.lt', 'where.version.lte', 'where.version.like', 'where.version.ilike', 'where.version.in', 'where.version.nin', 'where.version.contains', 'where.version.contained', 'where.version.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.version']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generations/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerations']} */
export const getGenerations = async (request) => {
  return await _getGenerations(baseUrl, request)
}
async function _createGeneration (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generations/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createGeneration']} */
export const createGeneration = async (request) => {
  return await _createGeneration(baseUrl, request)
}
async function _updateGenerations (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.version.eq', 'where.version.neq', 'where.version.gt', 'where.version.gte', 'where.version.lt', 'where.version.lte', 'where.version.like', 'where.version.ilike', 'where.version.in', 'where.version.nin', 'where.version.contains', 'where.version.contained', 'where.version.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generations/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateGenerations']} */
export const updateGenerations = async (request) => {
  return await _updateGenerations(baseUrl, request)
}
async function _getGenerationById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generations/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationById']} */
export const getGenerationById = async (request) => {
  return await _getGenerationById(baseUrl, request)
}
async function _updateGeneration (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generations/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateGeneration']} */
export const updateGeneration = async (request) => {
  return await _updateGeneration(baseUrl, request)
}
async function _deleteGenerations (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generations/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteGenerations']} */
export const deleteGenerations = async (request) => {
  return await _deleteGenerations(baseUrl, request)
}
async function _getGraphsForGeneration (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generations/${request['id']}/graphs?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGraphsForGeneration']} */
export const getGraphsForGeneration = async (request) => {
  return await _getGraphsForGeneration(baseUrl, request)
}
async function _getGenerationsDeploymentsForGeneration (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generations/${request['id']}/generationsDeploymentGenerationId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsDeploymentsForGeneration']} */
export const getGenerationsDeploymentsForGeneration = async (request) => {
  return await _getGenerationsDeploymentsForGeneration(baseUrl, request)
}
async function _getGenerationsApplicationsConfigsForGeneration (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generations/${request['id']}/generationsApplicationsConfigGenerationId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsApplicationsConfigsForGeneration']} */
export const getGenerationsApplicationsConfigsForGeneration = async (request) => {
  return await _getGenerationsApplicationsConfigsForGeneration(baseUrl, request)
}
async function _getGraphs (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.ilike', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.graph.eq', 'where.graph.neq', 'where.graph.gt', 'where.graph.gte', 'where.graph.lt', 'where.graph.lte', 'where.graph.like', 'where.graph.ilike', 'where.graph.in', 'where.graph.nin', 'where.graph.contains', 'where.graph.contained', 'where.graph.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or', 'orderby.createdAt', 'orderby.generationId', 'orderby.graph', 'orderby.id']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/graphs/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGraphs']} */
export const getGraphs = async (request) => {
  return await _getGraphs(baseUrl, request)
}
async function _createGraph (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/graphs/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createGraph']} */
export const createGraph = async (request) => {
  return await _createGraph(baseUrl, request)
}
async function _updateGraphs (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.ilike', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.graph.eq', 'where.graph.neq', 'where.graph.gt', 'where.graph.gte', 'where.graph.lt', 'where.graph.lte', 'where.graph.like', 'where.graph.ilike', 'where.graph.in', 'where.graph.nin', 'where.graph.contains', 'where.graph.contained', 'where.graph.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/graphs/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateGraphs']} */
export const updateGraphs = async (request) => {
  return await _updateGraphs(baseUrl, request)
}
async function _getGraphById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/graphs/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGraphById']} */
export const getGraphById = async (request) => {
  return await _getGraphById(baseUrl, request)
}
async function _updateGraph (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/graphs/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateGraph']} */
export const updateGraph = async (request) => {
  return await _updateGraph(baseUrl, request)
}
async function _deleteGraphs (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/graphs/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteGraphs']} */
export const deleteGraphs = async (request) => {
  return await _deleteGraphs(baseUrl, request)
}
async function _getGenerationForGraph (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/graphs/${request['id']}/generation?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationForGraph']} */
export const getGenerationForGraph = async (request) => {
  return await _getGenerationForGraph(baseUrl, request)
}
async function _getApplications (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.name']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applications/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplications']} */
export const getApplications = async (request) => {
  return await _getApplications(baseUrl, request)
}
async function _createApplication (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applications/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createApplication']} */
export const createApplication = async (request) => {
  return await _createApplication(baseUrl, request)
}
async function _updateApplications (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applications/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateApplications']} */
export const updateApplications = async (request) => {
  return await _updateApplications(baseUrl, request)
}
async function _getApplicationById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applications/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationById']} */
export const getApplicationById = async (request) => {
  return await _getApplicationById(baseUrl, request)
}
async function _updateApplication (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applications/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateApplication']} */
export const updateApplication = async (request) => {
  return await _updateApplication(baseUrl, request)
}
async function _deleteApplications (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applications/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteApplications']} */
export const deleteApplications = async (request) => {
  return await _deleteApplications(baseUrl, request)
}
async function _getApplicationsConfigsForApplication (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applications/${request['id']}/applicationsConfigs?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationsConfigsForApplication']} */
export const getApplicationsConfigsForApplication = async (request) => {
  return await _getApplicationsConfigsForApplication(baseUrl, request)
}
async function _getApplicationStatesForApplication (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applications/${request['id']}/applicationStates?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationStatesForApplication']} */
export const getApplicationStatesForApplication = async (request) => {
  return await _getApplicationStatesForApplication(baseUrl, request)
}
async function _getDeploymentsForApplication (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applications/${request['id']}/deploymentApplicationId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDeploymentsForApplication']} */
export const getDeploymentsForApplication = async (request) => {
  return await _getDeploymentsForApplication(baseUrl, request)
}
async function _getDetectedPodsForApplication (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applications/${request['id']}/detectedPodApplicationId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDetectedPodsForApplication']} */
export const getDetectedPodsForApplication = async (request) => {
  return await _getDetectedPodsForApplication(baseUrl, request)
}
async function _getApplicationsConfigs (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.resources.eq', 'where.resources.neq', 'where.resources.gt', 'where.resources.gte', 'where.resources.lt', 'where.resources.lte', 'where.resources.like', 'where.resources.ilike', 'where.resources.in', 'where.resources.nin', 'where.resources.contains', 'where.resources.contained', 'where.resources.overlaps', 'where.version.eq', 'where.version.neq', 'where.version.gt', 'where.version.gte', 'where.version.lt', 'where.version.lte', 'where.version.like', 'where.version.ilike', 'where.version.in', 'where.version.nin', 'where.version.contains', 'where.version.contained', 'where.version.overlaps', 'where.or', 'orderby.applicationId', 'orderby.createdAt', 'orderby.id', 'orderby.resources', 'orderby.version']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationsConfigs/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationsConfigs']} */
export const getApplicationsConfigs = async (request) => {
  return await _getApplicationsConfigs(baseUrl, request)
}
async function _createApplicationsConfig (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationsConfigs/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createApplicationsConfig']} */
export const createApplicationsConfig = async (request) => {
  return await _createApplicationsConfig(baseUrl, request)
}
async function _updateApplicationsConfigs (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.resources.eq', 'where.resources.neq', 'where.resources.gt', 'where.resources.gte', 'where.resources.lt', 'where.resources.lte', 'where.resources.like', 'where.resources.ilike', 'where.resources.in', 'where.resources.nin', 'where.resources.contains', 'where.resources.contained', 'where.resources.overlaps', 'where.version.eq', 'where.version.neq', 'where.version.gt', 'where.version.gte', 'where.version.lt', 'where.version.lte', 'where.version.like', 'where.version.ilike', 'where.version.in', 'where.version.nin', 'where.version.contains', 'where.version.contained', 'where.version.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationsConfigs/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateApplicationsConfigs']} */
export const updateApplicationsConfigs = async (request) => {
  return await _updateApplicationsConfigs(baseUrl, request)
}
async function _getApplicationsConfigById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationsConfigs/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationsConfigById']} */
export const getApplicationsConfigById = async (request) => {
  return await _getApplicationsConfigById(baseUrl, request)
}
async function _updateApplicationsConfig (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationsConfigs/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateApplicationsConfig']} */
export const updateApplicationsConfig = async (request) => {
  return await _updateApplicationsConfig(baseUrl, request)
}
async function _deleteApplicationsConfigs (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationsConfigs/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteApplicationsConfigs']} */
export const deleteApplicationsConfigs = async (request) => {
  return await _deleteApplicationsConfigs(baseUrl, request)
}
async function _getGenerationsApplicationsConfigsForApplicationsConfig (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationsConfigs/${request['id']}/generationsApplicationsConfigConfigId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsApplicationsConfigsForApplicationsConfig']} */
export const getGenerationsApplicationsConfigsForApplicationsConfig = async (request) => {
  return await _getGenerationsApplicationsConfigsForApplicationsConfig(baseUrl, request)
}
async function _getApplicationForApplicationsConfig (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationsConfigs/${request['id']}/application?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationForApplicationsConfig']} */
export const getApplicationForApplicationsConfig = async (request) => {
  return await _getApplicationForApplicationsConfig(baseUrl, request)
}
async function _getApplicationStates (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.pltVersion.eq', 'where.pltVersion.neq', 'where.pltVersion.gt', 'where.pltVersion.gte', 'where.pltVersion.lt', 'where.pltVersion.lte', 'where.pltVersion.like', 'where.pltVersion.ilike', 'where.pltVersion.in', 'where.pltVersion.nin', 'where.pltVersion.contains', 'where.pltVersion.contained', 'where.pltVersion.overlaps', 'where.state.eq', 'where.state.neq', 'where.state.gt', 'where.state.gte', 'where.state.lt', 'where.state.lte', 'where.state.like', 'where.state.ilike', 'where.state.in', 'where.state.nin', 'where.state.contains', 'where.state.contained', 'where.state.overlaps', 'where.or', 'orderby.applicationId', 'orderby.createdAt', 'orderby.id', 'orderby.pltVersion', 'orderby.state']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationStates/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationStates']} */
export const getApplicationStates = async (request) => {
  return await _getApplicationStates(baseUrl, request)
}
async function _createApplicationState (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationStates/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createApplicationState']} */
export const createApplicationState = async (request) => {
  return await _createApplicationState(baseUrl, request)
}
async function _updateApplicationStates (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.pltVersion.eq', 'where.pltVersion.neq', 'where.pltVersion.gt', 'where.pltVersion.gte', 'where.pltVersion.lt', 'where.pltVersion.lte', 'where.pltVersion.like', 'where.pltVersion.ilike', 'where.pltVersion.in', 'where.pltVersion.nin', 'where.pltVersion.contains', 'where.pltVersion.contained', 'where.pltVersion.overlaps', 'where.state.eq', 'where.state.neq', 'where.state.gt', 'where.state.gte', 'where.state.lt', 'where.state.lte', 'where.state.like', 'where.state.ilike', 'where.state.in', 'where.state.nin', 'where.state.contains', 'where.state.contained', 'where.state.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationStates/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateApplicationStates']} */
export const updateApplicationStates = async (request) => {
  return await _updateApplicationStates(baseUrl, request)
}
async function _getApplicationStateById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationStates/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationStateById']} */
export const getApplicationStateById = async (request) => {
  return await _getApplicationStateById(baseUrl, request)
}
async function _updateApplicationState (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationStates/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateApplicationState']} */
export const updateApplicationState = async (request) => {
  return await _updateApplicationState(baseUrl, request)
}
async function _deleteApplicationStates (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applicationStates/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteApplicationStates']} */
export const deleteApplicationStates = async (request) => {
  return await _deleteApplicationStates(baseUrl, request)
}
async function _getDeploymentsForApplicationState (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationStates/${request['id']}/deploymentApplicationStateId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDeploymentsForApplicationState']} */
export const getDeploymentsForApplicationState = async (request) => {
  return await _getDeploymentsForApplicationState(baseUrl, request)
}
async function _getApplicationForApplicationState (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/applicationStates/${request['id']}/application?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationForApplicationState']} */
export const getApplicationForApplicationState = async (request) => {
  return await _getApplicationForApplicationState(baseUrl, request)
}
async function _getDeployments (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.applicationStateId.eq', 'where.applicationStateId.neq', 'where.applicationStateId.gt', 'where.applicationStateId.gte', 'where.applicationStateId.lt', 'where.applicationStateId.lte', 'where.applicationStateId.like', 'where.applicationStateId.ilike', 'where.applicationStateId.in', 'where.applicationStateId.nin', 'where.applicationStateId.contains', 'where.applicationStateId.contained', 'where.applicationStateId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.imageId.eq', 'where.imageId.neq', 'where.imageId.gt', 'where.imageId.gte', 'where.imageId.lt', 'where.imageId.lte', 'where.imageId.like', 'where.imageId.ilike', 'where.imageId.in', 'where.imageId.nin', 'where.imageId.contains', 'where.imageId.contained', 'where.imageId.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.ilike', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or', 'orderby.applicationId', 'orderby.applicationStateId', 'orderby.createdAt', 'orderby.id', 'orderby.imageId', 'orderby.status']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/deployments/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDeployments']} */
export const getDeployments = async (request) => {
  return await _getDeployments(baseUrl, request)
}
async function _createDeployment (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/deployments/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createDeployment']} */
export const createDeployment = async (request) => {
  return await _createDeployment(baseUrl, request)
}
async function _updateDeployments (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.applicationStateId.eq', 'where.applicationStateId.neq', 'where.applicationStateId.gt', 'where.applicationStateId.gte', 'where.applicationStateId.lt', 'where.applicationStateId.lte', 'where.applicationStateId.like', 'where.applicationStateId.ilike', 'where.applicationStateId.in', 'where.applicationStateId.nin', 'where.applicationStateId.contains', 'where.applicationStateId.contained', 'where.applicationStateId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.imageId.eq', 'where.imageId.neq', 'where.imageId.gt', 'where.imageId.gte', 'where.imageId.lt', 'where.imageId.lte', 'where.imageId.like', 'where.imageId.ilike', 'where.imageId.in', 'where.imageId.nin', 'where.imageId.contains', 'where.imageId.contained', 'where.imageId.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.ilike', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/deployments/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateDeployments']} */
export const updateDeployments = async (request) => {
  return await _updateDeployments(baseUrl, request)
}
async function _getDeploymentById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/deployments/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDeploymentById']} */
export const getDeploymentById = async (request) => {
  return await _getDeploymentById(baseUrl, request)
}
async function _updateDeployment (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/deployments/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateDeployment']} */
export const updateDeployment = async (request) => {
  return await _updateDeployment(baseUrl, request)
}
async function _deleteDeployments (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/deployments/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteDeployments']} */
export const deleteDeployments = async (request) => {
  return await _deleteDeployments(baseUrl, request)
}
async function _getDetectedPodsForDeployment (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/deployments/${request['id']}/detectedPodDeploymentId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDetectedPodsForDeployment']} */
export const getDetectedPodsForDeployment = async (request) => {
  return await _getDetectedPodsForDeployment(baseUrl, request)
}
async function _getGenerationsDeploymentsForDeployment (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/deployments/${request['id']}/generationsDeploymentDeploymentId?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsDeploymentsForDeployment']} */
export const getGenerationsDeploymentsForDeployment = async (request) => {
  return await _getGenerationsDeploymentsForDeployment(baseUrl, request)
}
async function _getApplicationForDeployment (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/deployments/${request['id']}/application?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationForDeployment']} */
export const getApplicationForDeployment = async (request) => {
  return await _getApplicationForDeployment(baseUrl, request)
}
async function _getApplicationStateForDeployment (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/deployments/${request['id']}/application_state?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationStateForDeployment']} */
export const getApplicationStateForDeployment = async (request) => {
  return await _getApplicationStateForDeployment(baseUrl, request)
}
async function _getDetectedPods (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.deploymentId.eq', 'where.deploymentId.neq', 'where.deploymentId.gt', 'where.deploymentId.gte', 'where.deploymentId.lt', 'where.deploymentId.lte', 'where.deploymentId.like', 'where.deploymentId.ilike', 'where.deploymentId.in', 'where.deploymentId.nin', 'where.deploymentId.contains', 'where.deploymentId.contained', 'where.deploymentId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.podId.eq', 'where.podId.neq', 'where.podId.gt', 'where.podId.gte', 'where.podId.lt', 'where.podId.lte', 'where.podId.like', 'where.podId.ilike', 'where.podId.in', 'where.podId.nin', 'where.podId.contains', 'where.podId.contained', 'where.podId.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.ilike', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or', 'orderby.applicationId', 'orderby.createdAt', 'orderby.deploymentId', 'orderby.id', 'orderby.podId', 'orderby.status']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/detectedPods/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDetectedPods']} */
export const getDetectedPods = async (request) => {
  return await _getDetectedPods(baseUrl, request)
}
async function _createDetectedPod (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/detectedPods/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createDetectedPod']} */
export const createDetectedPod = async (request) => {
  return await _createDetectedPod(baseUrl, request)
}
async function _updateDetectedPods (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.ilike', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.deploymentId.eq', 'where.deploymentId.neq', 'where.deploymentId.gt', 'where.deploymentId.gte', 'where.deploymentId.lt', 'where.deploymentId.lte', 'where.deploymentId.like', 'where.deploymentId.ilike', 'where.deploymentId.in', 'where.deploymentId.nin', 'where.deploymentId.contains', 'where.deploymentId.contained', 'where.deploymentId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.podId.eq', 'where.podId.neq', 'where.podId.gt', 'where.podId.gte', 'where.podId.lt', 'where.podId.lte', 'where.podId.like', 'where.podId.ilike', 'where.podId.in', 'where.podId.nin', 'where.podId.contains', 'where.podId.contained', 'where.podId.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.ilike', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/detectedPods/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateDetectedPods']} */
export const updateDetectedPods = async (request) => {
  return await _updateDetectedPods(baseUrl, request)
}
async function _getDetectedPodById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/detectedPods/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDetectedPodById']} */
export const getDetectedPodById = async (request) => {
  return await _getDetectedPodById(baseUrl, request)
}
async function _updateDetectedPod (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/detectedPods/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateDetectedPod']} */
export const updateDetectedPod = async (request) => {
  return await _updateDetectedPod(baseUrl, request)
}
async function _deleteDetectedPods (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/detectedPods/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteDetectedPods']} */
export const deleteDetectedPods = async (request) => {
  return await _deleteDetectedPods(baseUrl, request)
}
async function _getApplicationForDetectedPod (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/detectedPods/${request['id']}/application?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getApplicationForDetectedPod']} */
export const getApplicationForDetectedPod = async (request) => {
  return await _getApplicationForDetectedPod(baseUrl, request)
}
async function _getDeploymentForDetectedPod (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/detectedPods/${request['id']}/deployment?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getDeploymentForDetectedPod']} */
export const getDeploymentForDetectedPod = async (request) => {
  return await _getDeploymentForDetectedPod(baseUrl, request)
}
async function _getGenerationsDeployments (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.deploymentId.eq', 'where.deploymentId.neq', 'where.deploymentId.gt', 'where.deploymentId.gte', 'where.deploymentId.lt', 'where.deploymentId.lte', 'where.deploymentId.like', 'where.deploymentId.ilike', 'where.deploymentId.in', 'where.deploymentId.nin', 'where.deploymentId.contains', 'where.deploymentId.contained', 'where.deploymentId.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.ilike', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.or', 'orderby.deploymentId', 'orderby.generationId']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generationsDeployments/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsDeployments']} */
export const getGenerationsDeployments = async (request) => {
  return await _getGenerationsDeployments(baseUrl, request)
}
async function _createGenerationsDeployment (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsDeployments/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createGenerationsDeployment']} */
export const createGenerationsDeployment = async (request) => {
  return await _createGenerationsDeployment(baseUrl, request)
}
async function _updateGenerationsDeployments (url, request) {
  const queryParameters = ['fields', 'where.deploymentId.eq', 'where.deploymentId.neq', 'where.deploymentId.gt', 'where.deploymentId.gte', 'where.deploymentId.lt', 'where.deploymentId.lte', 'where.deploymentId.like', 'where.deploymentId.ilike', 'where.deploymentId.in', 'where.deploymentId.nin', 'where.deploymentId.contains', 'where.deploymentId.contained', 'where.deploymentId.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.ilike', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsDeployments/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateGenerationsDeployments']} */
export const updateGenerationsDeployments = async (request) => {
  return await _updateGenerationsDeployments(baseUrl, request)
}
async function _getGenerationsDeploymentByGenerationIdAndDeploymentId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generationsDeployments/generation/${request['generationId']}/deployment/${request['deploymentId']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsDeploymentByGenerationIdAndDeploymentId']} */
export const getGenerationsDeploymentByGenerationIdAndDeploymentId = async (request) => {
  return await _getGenerationsDeploymentByGenerationIdAndDeploymentId(baseUrl, request)
}
async function _postGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsDeployments/generation/${request['generationId']}/deployment/${request['deploymentId']}?${searchParams.toString()}`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['postGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId']} */
export const postGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId = async (request) => {
  return await _postGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId(baseUrl, request)
}
async function _putGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsDeployments/generation/${request['generationId']}/deployment/${request['deploymentId']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['putGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId']} */
export const putGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId = async (request) => {
  return await _putGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId(baseUrl, request)
}
async function _deleteGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsDeployments/generation/${request['generationId']}/deployment/${request['deploymentId']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId']} */
export const deleteGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId = async (request) => {
  return await _deleteGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId(baseUrl, request)
}
async function _getGenerationsApplicationsConfigs (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.configId.eq', 'where.configId.neq', 'where.configId.gt', 'where.configId.gte', 'where.configId.lt', 'where.configId.lte', 'where.configId.like', 'where.configId.ilike', 'where.configId.in', 'where.configId.nin', 'where.configId.contains', 'where.configId.contained', 'where.configId.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.ilike', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.or', 'orderby.configId', 'orderby.generationId']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsApplicationsConfigs']} */
export const getGenerationsApplicationsConfigs = async (request) => {
  return await _getGenerationsApplicationsConfigs(baseUrl, request)
}
async function _createGenerationsApplicationsConfig (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['createGenerationsApplicationsConfig']} */
export const createGenerationsApplicationsConfig = async (request) => {
  return await _createGenerationsApplicationsConfig(baseUrl, request)
}
async function _updateGenerationsApplicationsConfigs (url, request) {
  const queryParameters = ['fields', 'where.configId.eq', 'where.configId.neq', 'where.configId.gt', 'where.configId.gte', 'where.configId.lt', 'where.configId.lte', 'where.configId.like', 'where.configId.ilike', 'where.configId.in', 'where.configId.nin', 'where.configId.contains', 'where.configId.contained', 'where.configId.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.ilike', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['updateGenerationsApplicationsConfigs']} */
export const updateGenerationsApplicationsConfigs = async (request) => {
  return await _updateGenerationsApplicationsConfigs(baseUrl, request)
}
async function _getGenerationsApplicationsConfigByGenerationIdAndConfigId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/generation/${request['generationId']}/applicationsConfig/${request['configId']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationsApplicationsConfigByGenerationIdAndConfigId']} */
export const getGenerationsApplicationsConfigByGenerationIdAndConfigId = async (request) => {
  return await _getGenerationsApplicationsConfigByGenerationIdAndConfigId(baseUrl, request)
}
async function _postGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/generation/${request['generationId']}/applicationsConfig/${request['configId']}?${searchParams.toString()}`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['postGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId']} */
export const postGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId = async (request) => {
  return await _postGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId(baseUrl, request)
}
async function _putGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/generation/${request['generationId']}/applicationsConfig/${request['configId']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['putGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId']} */
export const putGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId = async (request) => {
  return await _putGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId(baseUrl, request)
}
async function _deleteGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/generationsApplicationsConfigs/generation/${request['generationId']}/applicationsConfig/${request['configId']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['deleteGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId']} */
export const deleteGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId = async (request) => {
  return await _deleteGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId(baseUrl, request)
}
async function _getGenerationGraph (url, request) {
  const queryParameters = ['generationId']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/graph?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['getGenerationGraph']} */
export const getGenerationGraph = async (request) => {
  return await _getGenerationGraph(baseUrl, request)
}
async function _initApplicationInstance (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/pods/${request['podId']}/instance`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['initApplicationInstance']} */
export const initApplicationInstance = async (request) => {
  return await _initApplicationInstance(baseUrl, request)
}
async function _saveApplicationInstanceStatus (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/pods/${request['id']}/instance/status`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['saveApplicationInstanceStatus']} */
export const saveApplicationInstanceStatus = async (request) => {
  return await _saveApplicationInstanceStatus(baseUrl, request)
}
async function _saveApplicationInstanceState (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/pods/${request['id']}/instance/state`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['saveApplicationInstanceState']} */
export const saveApplicationInstanceState = async (request) => {
  return await _saveApplicationInstanceState(baseUrl, request)
}
async function _setApplicationResources (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/applications/${request['id']}/resources`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./control-plane-types.d.ts').ControlPlane['setApplicationResources']} */
export const setApplicationResources = async (request) => {
  return await _setApplicationResources(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getGenerations: _getGenerations.bind(url, ...arguments),
    createGeneration: _createGeneration.bind(url, ...arguments),
    updateGenerations: _updateGenerations.bind(url, ...arguments),
    getGenerationById: _getGenerationById.bind(url, ...arguments),
    updateGeneration: _updateGeneration.bind(url, ...arguments),
    deleteGenerations: _deleteGenerations.bind(url, ...arguments),
    getGraphsForGeneration: _getGraphsForGeneration.bind(url, ...arguments),
    getGenerationsDeploymentsForGeneration: _getGenerationsDeploymentsForGeneration.bind(url, ...arguments),
    getGenerationsApplicationsConfigsForGeneration: _getGenerationsApplicationsConfigsForGeneration.bind(url, ...arguments),
    getGraphs: _getGraphs.bind(url, ...arguments),
    createGraph: _createGraph.bind(url, ...arguments),
    updateGraphs: _updateGraphs.bind(url, ...arguments),
    getGraphById: _getGraphById.bind(url, ...arguments),
    updateGraph: _updateGraph.bind(url, ...arguments),
    deleteGraphs: _deleteGraphs.bind(url, ...arguments),
    getGenerationForGraph: _getGenerationForGraph.bind(url, ...arguments),
    getApplications: _getApplications.bind(url, ...arguments),
    createApplication: _createApplication.bind(url, ...arguments),
    updateApplications: _updateApplications.bind(url, ...arguments),
    getApplicationById: _getApplicationById.bind(url, ...arguments),
    updateApplication: _updateApplication.bind(url, ...arguments),
    deleteApplications: _deleteApplications.bind(url, ...arguments),
    getApplicationsConfigsForApplication: _getApplicationsConfigsForApplication.bind(url, ...arguments),
    getApplicationStatesForApplication: _getApplicationStatesForApplication.bind(url, ...arguments),
    getDeploymentsForApplication: _getDeploymentsForApplication.bind(url, ...arguments),
    getDetectedPodsForApplication: _getDetectedPodsForApplication.bind(url, ...arguments),
    getApplicationsConfigs: _getApplicationsConfigs.bind(url, ...arguments),
    createApplicationsConfig: _createApplicationsConfig.bind(url, ...arguments),
    updateApplicationsConfigs: _updateApplicationsConfigs.bind(url, ...arguments),
    getApplicationsConfigById: _getApplicationsConfigById.bind(url, ...arguments),
    updateApplicationsConfig: _updateApplicationsConfig.bind(url, ...arguments),
    deleteApplicationsConfigs: _deleteApplicationsConfigs.bind(url, ...arguments),
    getGenerationsApplicationsConfigsForApplicationsConfig: _getGenerationsApplicationsConfigsForApplicationsConfig.bind(url, ...arguments),
    getApplicationForApplicationsConfig: _getApplicationForApplicationsConfig.bind(url, ...arguments),
    getApplicationStates: _getApplicationStates.bind(url, ...arguments),
    createApplicationState: _createApplicationState.bind(url, ...arguments),
    updateApplicationStates: _updateApplicationStates.bind(url, ...arguments),
    getApplicationStateById: _getApplicationStateById.bind(url, ...arguments),
    updateApplicationState: _updateApplicationState.bind(url, ...arguments),
    deleteApplicationStates: _deleteApplicationStates.bind(url, ...arguments),
    getDeploymentsForApplicationState: _getDeploymentsForApplicationState.bind(url, ...arguments),
    getApplicationForApplicationState: _getApplicationForApplicationState.bind(url, ...arguments),
    getDeployments: _getDeployments.bind(url, ...arguments),
    createDeployment: _createDeployment.bind(url, ...arguments),
    updateDeployments: _updateDeployments.bind(url, ...arguments),
    getDeploymentById: _getDeploymentById.bind(url, ...arguments),
    updateDeployment: _updateDeployment.bind(url, ...arguments),
    deleteDeployments: _deleteDeployments.bind(url, ...arguments),
    getDetectedPodsForDeployment: _getDetectedPodsForDeployment.bind(url, ...arguments),
    getGenerationsDeploymentsForDeployment: _getGenerationsDeploymentsForDeployment.bind(url, ...arguments),
    getApplicationForDeployment: _getApplicationForDeployment.bind(url, ...arguments),
    getApplicationStateForDeployment: _getApplicationStateForDeployment.bind(url, ...arguments),
    getDetectedPods: _getDetectedPods.bind(url, ...arguments),
    createDetectedPod: _createDetectedPod.bind(url, ...arguments),
    updateDetectedPods: _updateDetectedPods.bind(url, ...arguments),
    getDetectedPodById: _getDetectedPodById.bind(url, ...arguments),
    updateDetectedPod: _updateDetectedPod.bind(url, ...arguments),
    deleteDetectedPods: _deleteDetectedPods.bind(url, ...arguments),
    getApplicationForDetectedPod: _getApplicationForDetectedPod.bind(url, ...arguments),
    getDeploymentForDetectedPod: _getDeploymentForDetectedPod.bind(url, ...arguments),
    getGenerationsDeployments: _getGenerationsDeployments.bind(url, ...arguments),
    createGenerationsDeployment: _createGenerationsDeployment.bind(url, ...arguments),
    updateGenerationsDeployments: _updateGenerationsDeployments.bind(url, ...arguments),
    getGenerationsDeploymentByGenerationIdAndDeploymentId: _getGenerationsDeploymentByGenerationIdAndDeploymentId.bind(url, ...arguments),
    postGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId: _postGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId.bind(url, ...arguments),
    putGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId: _putGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId.bind(url, ...arguments),
    deleteGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId: _deleteGenerationsDeploymentsGenerationGenerationIdDeploymentDeploymentId.bind(url, ...arguments),
    getGenerationsApplicationsConfigs: _getGenerationsApplicationsConfigs.bind(url, ...arguments),
    createGenerationsApplicationsConfig: _createGenerationsApplicationsConfig.bind(url, ...arguments),
    updateGenerationsApplicationsConfigs: _updateGenerationsApplicationsConfigs.bind(url, ...arguments),
    getGenerationsApplicationsConfigByGenerationIdAndConfigId: _getGenerationsApplicationsConfigByGenerationIdAndConfigId.bind(url, ...arguments),
    postGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId: _postGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId.bind(url, ...arguments),
    putGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId: _putGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId.bind(url, ...arguments),
    deleteGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId: _deleteGenerationsApplicationsConfigsGenerationGenerationIdApplicationsConfigConfigId.bind(url, ...arguments),
    getGenerationGraph: _getGenerationGraph.bind(url, ...arguments),
    initApplicationInstance: _initApplicationInstance.bind(url, ...arguments),
    saveApplicationInstanceStatus: _saveApplicationInstanceStatus.bind(url, ...arguments),
    saveApplicationInstanceState: _saveApplicationInstanceState.bind(url, ...arguments),
    setApplicationResources: _setApplicationResources.bind(url, ...arguments)
  }
}