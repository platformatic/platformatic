'use strict'

const createError = require('@fastify/error')
const { BaseGenerator } = require('@platformatic/generators')
const { existsSync } = require('node:fs')
const { join, basename } = require('node:path')
const { envObjectToString } = require('@platformatic/generators/lib/utils')
const { readFile, readdir, stat } = require('node:fs/promises')
const { transform } = require('./config')
const { getServiceTemplateFromSchemaUrl } = require('@platformatic/generators/lib/utils')
const { DotEnvTool } = require('dotenv-tool')
const { getArrayDifference } = require('./utils')
const { schema } = require('./schema')
const { pathToFileURL } = require('node:url')
const {
  safeRemove,
  generateDashedName,
  findConfigurationFile,
  loadConfiguration,
  loadConfigurationFile,
  kMetadata,
  defaultPackageManager
} = require('@platformatic/utils')
const { createRequire } = require('node:module')

const wrappableProperties = {
  logger: {
    level: '{PLT_SERVER_LOGGER_LEVEL}'
  },
  server: {
    hostname: '{PLT_SERVER_HOSTNAME}',
    port: '{PORT}'
  },
  managementApi: '{PLT_MANAGEMENT_API}'
}

const engines = {
  node: '>=22.18.0'
}

const ERROR_PREFIX = 'PLT_RUNTIME_GEN'

const NoServiceNamedError = createError(
  `${ERROR_PREFIX}_NO_SERVICE_FOUND`,
  "No service named '%s' has been added to this runtime."
)
const NoEntryPointError = createError(`${ERROR_PREFIX}_NO_ENTRYPOINT`, 'No entrypoint had been defined.')

function getRuntimeBaseEnvVars (config) {
  return {
    PLT_SERVER_HOSTNAME: '127.0.0.1',
    PORT: config.port || 3042,
    PLT_SERVER_LOGGER_LEVEL: config.logLevel || 'info',
    PLT_MANAGEMENT_API: true
  }
}

class RuntimeGenerator extends BaseGenerator {
  constructor (opts) {
    super({
      ...opts,
      module: '@platformatic/runtime'
    })
    this.runtimeName = opts.name
    this.servicesFolder = opts.servicesFolder ?? 'services'
    this.services = []
    this.existingServices = []
    this.entryPoint = null
    this.packageManager = opts.packageManager ?? defaultPackageManager
  }

  async addService (service, name) {
    // ensure service config is correct
    const originalConfig = service.config
    const serviceName = name || generateDashedName()
    const newConfig = {
      ...originalConfig,
      isRuntimeContext: true,
      serviceName
    }
    // reset all files previously generated by the service
    service.reset()
    service.setConfig(newConfig)
    this.services.push({
      name: serviceName,
      service
    })

    service.setRuntime(this)
  }

  setEntryPoint (entryPoint) {
    const service = this.existingServices.includes(entryPoint) || this.services.find(svc => svc.name === entryPoint)
    if (!service) {
      throw new NoServiceNamedError(entryPoint)
    }
    this.entryPoint = service
  }

  async generatePackageJson () {
    const template = {
      name: `${this.runtimeName}`,
      scripts: {
        dev: this.config.devCommand,
        build: this.config.buildCommand,
        start: this.config.startCommand ?? 'platformatic start'
      },
      devDependencies: {
        fastify: `^${this.fastifyVersion}`,
        borp: `${this.pkgData.devDependencies.borp}`
      },
      dependencies: {
        '@platformatic/runtime': `^${this.platformaticVersion}`,
        platformatic: `^${this.platformaticVersion}`,
        wattpm: `^${this.platformaticVersion}`,
        ...this.config.dependencies
      },
      engines
    }

    if (this.packageManager === 'npm' || this.packageManager === 'yarn') {
      template.workspaces = [this.servicesFolder + '/*']
    }

    return template
  }

  async _beforePrepare () {
    this.setServicesDirectory()
    this.setServicesConfigValues()
    this.addServicesDependencies()

    this.addEnvVars(getRuntimeBaseEnvVars(this.config), { overwrite: false, default: true })
  }

  addServicesDependencies () {
    this.services.forEach(({ service }) => {
      if (service.config.dependencies) {
        Object.entries(service.config.dependencies).forEach(kv => {
          this.config.dependencies[kv[0]] = kv[1]
        })
      }
    })
  }

  async populateFromExistingConfig () {
    if (this._hasCheckedForExistingConfig) {
      return
    }
    this._hasCheckedForExistingConfig = true
    const existingConfigFile = this.runtimeConfig ?? (await findConfigurationFile(this.targetDirectory, 'runtime'))
    if (existingConfigFile && existsSync(join(this.targetDirectory, existingConfigFile))) {
      this.existingConfigRaw = await loadConfigurationFile(join(this.targetDirectory, existingConfigFile))
      this.existingConfig = await loadConfiguration(join(this.targetDirectory, existingConfigFile), schema, {
        transform,
        ignoreProcessEnv: true
      })

      const { PLT_ROOT, ...existingEnvironment } = this.existingConfig[kMetadata].env
      this.config.env = existingEnvironment
      this.config.port = this.config.env.PORT
      this.entryPoint = this.existingConfig.services.find(svc => svc.entrypoint)
      this.existingServices = this.existingConfig.services.map(s => s.id)

      this.updateRuntimeConfig(this.existingConfigRaw)
      this.updateRuntimeEnv(await readFile(join(this.targetDirectory, '.env'), 'utf-8'))
    }
  }

  async prepare () {
    await this.populateFromExistingConfig()
    if (this.existingConfig) {
      this.setServicesDirectory()
      this.setServicesConfigValues()
      await this._afterPrepare()
      return {
        env: this.config.env,
        targetDirectory: this.targetDirectory
      }
    } else {
      return await super.prepare()
    }
  }

  setServicesConfigValues () {
    this.services.forEach(({ service }) => {
      if (!service.config) {
        // set default config
        service.setConfig()
      }
    })
  }

  async _getConfigFileContents () {
    const config = {
      $schema: `https://schemas.platformatic.dev/@platformatic/runtime/${this.platformaticVersion}.json`,
      entrypoint: this.entryPoint.name,
      watch: true,
      autoload: {
        path: this.config.autoload || this.servicesFolder,
        exclude: ['docs']
      },
      ...wrappableProperties
    }

    return config
  }

  async _afterPrepare () {
    if (!this.entryPoint) {
      throw new NoEntryPointError()
    }
    const servicesEnv = await this.prepareServiceFiles()
    this.addEnvVars({
      ...this.config.env,
      ...this.getRuntimeEnv(),
      ...servicesEnv
    })

    this.updateRuntimeEnv(envObjectToString(this.config.env))

    this.addFile({
      path: '',
      file: '.env.sample',
      contents: envObjectToString(this.config.defaultEnv)
    })

    return {
      targetDirectory: this.targetDirectory,
      env: servicesEnv
    }
  }

  async writeFiles () {
    for (const { service } of this.services) {
      await service._beforeWriteFiles?.(this)
    }

    await super.writeFiles()

    if (!this.config.isUpdating) {
      for (const { service } of this.services) {
        await service.writeFiles()
      }
    }

    for (const { service } of this.services) {
      await service._afterWriteFiles?.(this)
    }
  }

  async prepareQuestions () {
    await this.populateFromExistingConfig()

    if (this.existingConfig) {
      return
    }

    // port
    this.questions.push({
      type: 'input',
      name: 'port',
      default: 3042,
      message: 'What port do you want to use?'
    })
  }

  setServicesDirectory () {
    this.services.forEach(({ service }) => {
      if (!service.config) {
        // set default config
        service.setConfig()
      }
      let basePath
      if (this.existingConfig) {
        basePath = this.existingConfig.autoload.path
      } else {
        basePath = join(this.targetDirectory, this.config.autoload || this.servicesFolder)
      }
      this.servicesBasePath = basePath
      service.setTargetDirectory(join(basePath, service.config.serviceName))
    })
  }

  setServicesConfig (configToOverride) {
    this.services.forEach(service => {
      const originalConfig = service.config
      service.setConfig({
        ...originalConfig,
        ...configToOverride
      })
    })
  }

  async prepareServiceFiles () {
    let servicesEnv = {}
    for (const svc of this.services) {
      const svcEnv = await svc.service.prepare()
      servicesEnv = {
        ...servicesEnv,
        ...svcEnv.env
      }
    }
    return servicesEnv
  }

  getConfigFieldsDefinitions () {
    return []
  }

  setConfigFields () {
    // do nothing, makes no sense
  }

  getRuntimeEnv () {
    return {
      PORT: this.config.port
    }
  }

  async postInstallActions () {
    for (const { service } of this.services) {
      await service.postInstallActions()
    }
  }

  async _getGeneratorForTemplate (dir, pkg) {
    const _require = createRequire(dir)
    const fileToImport = _require.resolve(pkg)
    return (await import(pathToFileURL(fileToImport))).Generator
  }

  async loadFromDir () {
    const output = {
      services: []
    }
    const runtimePkgConfigFileData = JSON.parse(await readFile(join(this.targetDirectory, this.runtimeConfig), 'utf-8'))
    const servicesPath = join(this.targetDirectory, runtimePkgConfigFileData.autoload.path)

    // load all services
    const allServices = await readdir(servicesPath)
    for (const s of allServices) {
      // check is a directory
      const currentServicePath = join(servicesPath, s)
      const dirStat = await stat(currentServicePath)
      if (dirStat.isDirectory()) {
        // load the service config
        const configFile = await findConfigurationFile(currentServicePath)
        const servicePltJson = JSON.parse(await readFile(join(currentServicePath, configFile), 'utf-8'))
        // get module to load
        const template = servicePltJson.module || getServiceTemplateFromSchemaUrl(servicePltJson.$schema)
        const Generator = await this._getGeneratorForTemplate(currentServicePath, template)
        const instance = new Generator({
          logger: this.logger
        })
        this.addService(instance, s)
        output.services.push(await instance.loadFromDir(s, this.targetDirectory))
      }
    }
    return output
  }

  async update (newConfig) {
    let allServicesDependencies = {}
    const runtimeAddedEnvKeys = []

    this.config.isUpdating = true
    const currrentPackageJson = JSON.parse(await readFile(join(this.targetDirectory, 'package.json'), 'utf-8'))
    const currentRuntimeDependencies = currrentPackageJson.dependencies
    // check all services are present with the same template
    const allCurrentServicesNames = this.services.map(s => s.name)
    const allNewServicesNames = newConfig.services.map(s => s.name)
    // load dotenv tool
    const envTool = new DotEnvTool({
      path: join(this.targetDirectory, '.env')
    })

    await envTool.load()

    const removedServices = getArrayDifference(allCurrentServicesNames, allNewServicesNames)
    if (removedServices.length > 0) {
      for (const removedService of removedServices) {
        // handle service delete

        // delete env variables
        const s = this.services.find(f => f.name === removedService)
        const allKeys = envTool.getKeys()
        allKeys.forEach(k => {
          if (k.startsWith(`PLT_${s.service.config.envPrefix}`)) {
            envTool.deleteKey(k)
          }
        })

        // delete dependencies
        const servicePath = join(this.targetDirectory, this.servicesFolder, s.name)
        const configFile = await findConfigurationFile(servicePath)
        const servicePackageJson = JSON.parse(await readFile(join(servicePath, configFile), 'utf-8'))
        if (servicePackageJson.plugins && servicePackageJson.plugins.packages) {
          servicePackageJson.plugins.packages.forEach(p => {
            delete currrentPackageJson.dependencies[p.name]
          })
        }
        // delete directory
        await safeRemove(join(this.targetDirectory, this.servicesFolder, s.name))
      }
      // throw new CannotRemoveServiceOnUpdateError(removedServices.join(', '))
    }

    // handle new services
    for (const newService of newConfig.services) {
      // create generator for the service
      const ServiceGenerator = await this._getGeneratorForTemplate(
        join(this.targetDirectory, 'package.json'),
        newService.template
      )
      const serviceInstance = new ServiceGenerator({
        logger: this.logger
      })
      const baseConfig = {
        isRuntimeContext: true,
        targetDirectory: join(this.targetDirectory, this.servicesFolder, newService.name),
        serviceName: newService.name,
        plugin: true
      }
      if (allCurrentServicesNames.includes(newService.name)) {
        // update existing services env values
        // otherwise, is a new service
        baseConfig.isUpdating = true

        // handle service's plugin differences
        const oldServiceMetadata = await serviceInstance.loadFromDir(newService.name, this.targetDirectory)
        const oldServicePackages = oldServiceMetadata.plugins.map(meta => meta.name)
        const newServicePackages = newService.plugins.map(meta => meta.name)
        const pluginsToRemove = getArrayDifference(oldServicePackages, newServicePackages)
        pluginsToRemove.forEach(p => delete currentRuntimeDependencies[p])
      } else {
        // add service to the generator
        this.services.push({
          name: newService.name,
          service: serviceInstance
        })
      }
      serviceInstance.setConfig(baseConfig)
      serviceInstance.setConfigFields(newService.fields)

      const serviceEnvPrefix = `PLT_${serviceInstance.config.envPrefix}`
      for (const plug of newService.plugins) {
        await serviceInstance.addPackage(plug)
        for (const opt of plug.options) {
          const key = `${serviceEnvPrefix}_${opt.name}`
          runtimeAddedEnvKeys.push(key)
          const value = opt.value
          if (envTool.hasKey(key)) {
            envTool.updateKey(key, value)
          } else {
            envTool.addKey(key, value)
          }
        }
      }
      allServicesDependencies = { ...allServicesDependencies, ...serviceInstance.config.dependencies }
      const afterPrepareMetadata = await serviceInstance.prepare()
      await serviceInstance.writeFiles()
      // cleanup runtime env removing keys not present anymore in service plugins
      const allKeys = envTool.getKeys()
      allKeys.forEach(k => {
        if (k.startsWith(`${serviceEnvPrefix}_FST_PLUGIN`) && !runtimeAddedEnvKeys.includes(k)) {
          envTool.deleteKey(k)
        }
      })

      // add service env variables to runtime env
      Object.entries(afterPrepareMetadata.env).forEach(([key, value]) => {
        envTool.addKey(key, value)
      })
    }
    // update runtime package.json dependencies
    currrentPackageJson.dependencies = {
      ...currrentPackageJson.dependencies,
      ...allServicesDependencies
    }
    this.addFile({
      path: '',
      file: 'package.json',
      contents: JSON.stringify(currrentPackageJson, null, 2)
    })

    // set new entrypoint if specified
    const newEntrypoint = newConfig.entrypoint
    if (newEntrypoint) {
      // load platformatic.json runtime config
      const runtimePkgConfigFileData = JSON.parse(
        await readFile(join(this.targetDirectory, this.runtimeConfig), 'utf-8')
      )

      this.setEntryPoint(newEntrypoint)
      runtimePkgConfigFileData.entrypoint = newEntrypoint
      this.updateRuntimeConfig(runtimePkgConfigFileData)
    }
    await this.writeFiles()
    // save new env
    await envTool.save()
  }

  async generateConfigFile () {
    this.updateRuntimeConfig(await super.generateConfigFile())
  }

  async generateEnv () {
    const serialized = await super.generateEnv()

    if (serialized) {
      this.updateRuntimeEnv(serialized)
    }
  }

  getRuntimeConfigFileObject () {
    return this.files.find(file => file.tags?.includes('runtime-config')) ?? null
  }

  getRuntimeEnvFileObject () {
    return this.files.find(file => file.tags?.includes('runtime-env')) ?? null
  }

  updateRuntimeConfig (config) {
    this.addFile({
      path: '',
      file: this.runtimeConfig,
      contents: JSON.stringify(config, null, 2),
      tags: ['runtime-config']
    })
  }

  updateRuntimeEnv (contents) {
    this.addFile({
      path: '',
      file: '.env',
      contents,
      tags: ['runtime-env']
    })
  }

  updateConfigEntryPoint (entrypoint) {
    // This can return null if the generator was not supposed to modify the config
    const configObject = this.getRuntimeConfigFileObject()
    const config = JSON.parse(configObject.contents)
    config.entrypoint = entrypoint

    this.updateRuntimeConfig(config)
  }
}

class WrappedGenerator extends BaseGenerator {
  async prepare () {
    await this.getPlatformaticVersion()
    await this.#updateEnvironment()
    await this.#updatePackageJson()
    await this.#createConfigFile()
  }

  async #updateEnvironment () {
    this.addEnvVars(getRuntimeBaseEnvVars(this.config), { overwrite: false, default: true })

    this.addFile({
      path: '',
      file: '.env',
      contents: (await this.#readExistingFile('.env', '', '\n')) + envObjectToString(this.config.env)
    })

    this.addFile({
      path: '',
      file: '.env.sample',
      contents: (await this.#readExistingFile('.env.sample', '', '\n')) + envObjectToString(this.config.defaultEnv)
    })
  }

  async #updatePackageJson () {
    // Manipulate the package.json, if any
    const packageJson = JSON.parse(await this.#readExistingFile('package.json', '{}'))
    let { name, dependencies, devDependencies, scripts, engines: packageJsonEngines, ...rest } = packageJson

    // Add the dependencies
    dependencies = {
      ...dependencies,
      [this.module]: `^${this.platformaticVersion}`,
      platformatic: `^${this.platformaticVersion}`,
      wattpm: `^${this.platformaticVersion}`
    }

    // For easier readbility, sort dependencies and devDependencies by name
    dependencies = Object.fromEntries(Object.entries(dependencies).sort(([a], [b]) => a.localeCompare(b)))
    devDependencies = Object.fromEntries(Object.entries(devDependencies ?? {}).sort(([a], [b]) => a.localeCompare(b)))

    scripts ??= {}
    scripts.dev ??= this.config.devCommand
    scripts.build ??= this.config.buildCommand
    scripts.start ??= this.config.startCommand ?? 'platformatic start'

    this.addFile({
      path: '',
      file: 'package.json',
      contents: JSON.stringify(
        {
          name: name ?? this.projectName ?? this.runtimeName ?? basename(this.targetDirectory),
          scripts,
          dependencies,
          devDependencies,
          ...rest,
          engines: { ...packageJsonEngines, ...engines }
        },
        null,
        2
      )
    })
  }

  async #createConfigFile () {
    const config = {
      $schema: `https://schemas.platformatic.dev/${this.module}/${this.platformaticVersion}.json`,
      runtime: wrappableProperties
    }

    this.addFile({
      path: '',
      file: 'watt.json',
      contents: JSON.stringify(config, null, 2)
    })
  }

  async #readExistingFile (path, emptyContents = '', suffix = '') {
    const filePath = join(this.targetDirectory, path)

    if (!existsSync(filePath)) {
      return emptyContents
    }

    const contents = await readFile(filePath, 'utf-8')
    return contents + suffix
  }
}

module.exports = {
  RuntimeGenerator,
  WrappedGenerator
}
