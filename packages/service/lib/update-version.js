'use strict'

const { join, relative } = require('node:path')
const { readFile, writeFile, mkdir, readdir, rm } = require('node:fs/promises')
const { inspect } = require('node:util')
const pino = require('pino')
const pretty = require('pino-pretty')
const cliProgress = require('cli-progress')
const { request } = require('undici')
const { green } = require('colorette')
const compareOpenApiSchemas = require('openapi-schema-diff')
const { default: CodeBlockWriter } = require('code-block-writer')
const { loadConfig, getParser, getStringifier } = require('@platformatic/config')
const { getOpenapiSchema } = require('./get-openapi-schema.js')
const { platformaticService } = require('../index.js')
const {
  isFileAccessible,
  changeOpenapiSchemaPrefix,
  convertOpenApiToFastifyPath,
  convertOpenApiToFastifyRouteSchema
} = require('./utils.js')

const OPENAI_SERVICE_HOST = 'https://openai.platformatic.cloud'
const OPENAI_WARNING = '// !!! This function was generated by OpenAI. Check before use !!!\n'

const HTTP_METHODS_WITH_BODY = ['POST', 'PUT', 'PATCH', 'DELETE']

async function generateRequestMapper (openaiProxyHost, userApiKey, content) {
  openaiProxyHost = openaiProxyHost ?? OPENAI_SERVICE_HOST

  const url = openaiProxyHost + '/openapi/mappers/request'
  const { statusCode, body } = await request(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-platformatic-user-api-key': userApiKey
    },
    body: JSON.stringify(content)
  })

  if (statusCode !== 200) {
    const error = await body.text()
    throw new Error('Failed to generate request mapper: ' + error)
  }

  const data = await body.json()
  return OPENAI_WARNING + data.code
}

async function generateResponseMapper (openaiProxyHost, userApiKey, content) {
  openaiProxyHost = openaiProxyHost ?? OPENAI_SERVICE_HOST

  const url = openaiProxyHost + '/openapi/mappers/response'
  const { statusCode, body } = await request(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-platformatic-user-api-key': userApiKey
    },
    body: JSON.stringify(content)
  })

  if (statusCode !== 200) {
    const error = await body.text()
    throw new Error('Failed to generate response mapper: ' + error)
  }

  const data = await body.json()
  return OPENAI_WARNING + data.code
}

async function generateMapperForDeletedRoute (
  logger,
  method,
  openapiPath,
  prevVersionConfig,
  nextVersionConfig,
  routeDiff
) {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  const nextVersion = nextVersionConfig.version

  const fastifySchema = convertOpenApiToFastifyRouteSchema(routeDiff.sourceSchema)
  const serializedFastifySchema = inspect(
    fastifySchema ?? {},
    {
      depth: null,
      compact: false
    }
  )

  writer.writeLine(
    `// Route ${method.toUpperCase()} "${openapiPath}" was deleted in the "${nextVersion}" API`
  )

  const fastifyPath = convertOpenApiToFastifyPath(openapiPath)

  const errorMessage =
    `Route ${method.toUpperCase()} "${openapiPath}" was deleted in the "${nextVersion}" API`

  writer.write('fastify.route({').indent(() => {
    writer.writeLine(`method: '${method.toUpperCase()}',`)
    writer.writeLine(`url: '${fastifyPath}',`)
    writer.writeLine(`schema: ${serializedFastifySchema},`)
    writer.write('handler: async (req, reply) => ').block(() => {
      writer.writeLine('reply').indent(() => {
        writer.writeLine('.code(404)')
        writer.writeLine('.send({').indent(() => {
          writer.writeLine('code: \'PLT_ERR_DELETED_ROUTE\',')
          writer.writeLine(`message: '${errorMessage}'`)
        }).write('})')
      })
    })
  }).write('})')

  return writer.toString()
}

function generateDefaultRequestMapper () {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  writer.writeLine('function mapInputData (inputData) {').indent(() => {
    writer.writeLine('// Map your input params here')
    writer.blankLine()
    writer.writeLine('delete inputData.headers.connection')
    writer.writeLine('delete inputData.headers[\'content-length\']')
    writer.writeLine('delete inputData.headers[\'transfer-encoding\']')
    writer.blankLine()
    writer.write('return {').indent(() => {
      writer.writeLine('pathParams: inputData.pathParams,')
      writer.writeLine('queryParams: inputData.queryParams,')
      writer.writeLine('headers: inputData.headers,')
      writer.writeLine('requestBody: inputData.requestBody')
    }).write('}')
  }).write('}\n')

  return writer.toString()
}

function generateDefaultResponseMapper () {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  writer.writeLine('function mapOutputData (outputData) {').indent(() => {
    writer.writeLine('// Map your output params here')
    writer.write('return {').indent(() => {
      writer.writeLine('headers: outputData.headers,')
      writer.writeLine('responseBody: outputData.responseBody')
    }).write('}')
  }).write('}\n')

  return writer.toString()
}

async function generateHandlerForChangedRoute (
  logger,
  method,
  openapiPath,
  prevVersionPrefix,
  nextVersionPrefix,
  routeDiff,
  userApiKey,
  openai,
  openaiProxyHost
) {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  const requestChanges = routeDiff.changes.filter(
    c => c.type === 'parameter' || c.type === 'requestBody'
  )
  const responseChanges = routeDiff.changes.filter(
    c => c.type === 'responseHeader' || c.type === 'responseBody'
  )

  const includeRequestBody = HTTP_METHODS_WITH_BODY.includes(method.toUpperCase())

  let genRequestMapperReq = null
  if (requestChanges.length > 0) {
    if (openai) {
      genRequestMapperReq = generateRequestMapper(
        openaiProxyHost,
        userApiKey,
        {
          includeBody: includeRequestBody,
          sourceSchema: {
            parameters: routeDiff.sourceSchema.parameters ?? [],
            requestBody: routeDiff.sourceSchema.requestBody ?? {}
          },
          targetSchema: {
            parameters: routeDiff.targetSchema.parameters ?? [],
            requestBody: routeDiff.targetSchema.requestBody ?? {}
          }
        }
      ).catch(async (err) => {
        logger.warn({ err }, 'Failed to generate request params mapper. Using default mapper.')
        return generateDefaultRequestMapper()
      })
    } else {
      genRequestMapperReq = generateDefaultRequestMapper()
    }
  }

  const mappedStatusCodes = []
  const getResponseMappersReqs = []

  const sourceSchemaResponses = routeDiff.sourceSchema.responses ?? {}
  const targetSchemaResponses = routeDiff.targetSchema.responses ?? {}

  for (const statusCode in targetSchemaResponses) {
    const targetSchemaResponse = targetSchemaResponses[statusCode]
    const sourceSchemaResponse = sourceSchemaResponses[statusCode]

    const genMapperReqBody = { sourceSchema: {}, targetSchema: {} }

    const headerChanges = responseChanges.filter(change =>
      change.type === 'responseHeader' &&
      change.statusCode === statusCode
    )

    const bodyChange = responseChanges.find(change =>
      change.action === 'changed' &&
      change.type === 'responseBody' &&
      change.statusCode === statusCode &&
      change.mediaType === 'application/json'
    )

    if (bodyChange || headerChanges.length > 0) {
      if (headerChanges.length > 0) {
        genMapperReqBody.targetSchema.headers = sourceSchemaResponse.headers
        genMapperReqBody.sourceSchema.headers = targetSchemaResponse.headers
      }
      if (bodyChange) {
        genMapperReqBody.targetSchema.responseBody = bodyChange.sourceSchema.schema
        genMapperReqBody.sourceSchema.responseBody = bodyChange.targetSchema.schema
      }

      let genResponseMapperReq = null
      if (openai) {
        genResponseMapperReq = generateResponseMapper(
          openaiProxyHost,
          userApiKey,
          genMapperReqBody
        ).catch(async (err) => {
          logger.warn({ err }, 'Failed to generate response params mapper. Using default mapper.')
          return generateDefaultResponseMapper()
        })
      } else {
        genResponseMapperReq = generateDefaultResponseMapper()
      }

      mappedStatusCodes.push(statusCode)
      getResponseMappersReqs.push(genResponseMapperReq)
    }
  }

  const [requestMapper, ...responseMappers] = await Promise.all([
    genRequestMapperReq,
    ...getResponseMappersReqs
  ])

  writer.write('async (req, reply) => ').block(() => {
    if (requestMapper) {
      writer.writeLine(requestMapper)
    }

    for (let i = 0; i < mappedStatusCodes.length; i++) {
      const statusCode = mappedStatusCodes[i]
      const responseMapper = responseMappers[i]

      const renamedResponseMapper = responseMapper.replace(
        'mapOutputData',
        `mapOutputData${statusCode}`
      )

      writer.writeLine(renamedResponseMapper)
    }

    if (requestMapper) {
      writer.write('const inputParams = mapInputData({').indent(() => {
        writer.writeLine('pathParams: req.params,')
        writer.writeLine('queryParams: req.query,')
        writer.writeLine('headers: req.headers,')
        if (includeRequestBody) {
          writer.writeLine('requestBody: req.body')
        }
      }).write('})')
    } else {
      writer.write('const inputParams = {').indent(() => {
        writer.writeLine('pathParams: req.params,')
        writer.writeLine('queryParams: req.query,')
        writer.writeLine('headers: req.headers,')
        if (includeRequestBody) {
          writer.writeLine('requestBody: req.body')
        }
      }
      ).write('}')
    }
    writer.blankLine()

    let nextRouteUrl = null
    const pathParams = openapiPath.match(/{(\w+)}/g) ?? []
    if (pathParams.length > 0) {
      let mappedPath = openapiPath
      for (const pathParam of pathParams) {
        let paramName = pathParam.slice(1, -1)
        paramName = paramName === 'wildcard' ? '*' : paramName
        mappedPath = mappedPath.replace(pathParam, '${params[\'' + paramName + '\']}')
      }

      writer.writeLine('const params = inputParams.pathParams')
      nextRouteUrl = `\`${nextVersionPrefix + mappedPath}\``
    } else {
      nextRouteUrl = `'${nextVersionPrefix + openapiPath}'`
    }

    writer.write('const res = await fastify.inject({').indent(() => {
      writer.writeLine('method: \'' + method.toUpperCase() + '\',')
      writer.writeLine(`url: ${nextRouteUrl},`)
      writer.writeLine('query: inputParams.queryParams,')
      writer.writeLine('headers: inputParams.headers,')
      if (includeRequestBody) {
        writer.writeLine('payload: inputParams.requestBody')
      }
    }).write('})')
    writer.blankLine()

    writer.write('let outputParams = {').indent(() => {
      writer.writeLine('headers: res.headers,')
      writer.writeLine('responseBody: res.body')
    }).write('}')
    writer.blankLine()

    for (let i = 0; i < mappedStatusCodes.length; i++) {
      const statusCode = mappedStatusCodes[i]
      const mapperFunctionName = `mapOutputData${statusCode}`

      writer.write(`if (res.statusCode === ${statusCode}) `).block(() => {
        writer.writeLine('const responseBody = outputParams.responseBody')
        writer.write('if (typeof responseBody === \'string\')').block(() => {
          writer.writeLine('outputParams.responseBody = JSON.parse(responseBody)')
        })
        writer.write(`outputParams = ${mapperFunctionName}(outputParams)`)
      })
      writer.blankLine()
    }

    writer.write('reply').indent(() => {
      writer.writeLine('.code(res.statusCode)')
      writer.writeLine('.headers(outputParams.headers)')
    })
    writer.blankLine()
    writer.writeLine('return outputParams.responseBody')
  })

  return writer.toString()
}

async function generateMapperForChangedRoute (
  logger,
  method,
  openapiPath,
  prevVersionConfig,
  nextVersionConfig,
  routeDiff,
  userApiKey,
  openai,
  openaiProxyHost
) {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  const nextVersion = nextVersionConfig.version

  const prevVersionPrefix = prevVersionConfig.openapi.prefix ?? ''
  const nextVersionPrefix = nextVersionConfig.openapi.prefix ?? ''

  writer.writeLine(
    `/* Route ${method.toUpperCase()} "${openapiPath}" was changed in the "${nextVersion}" API`
  )
  writer.indent(() => {
    for (const componentChange of routeDiff.changes) {
      writer.writeLine(`- ${componentChange.comment}`)
      if (componentChange.action !== 'changed') continue

      writer.indent(() => {
        for (const keywordChange of componentChange.changes ?? []) {
          writer.writeLine(`- ${keywordChange.comment}`)
          if (keywordChange.keyword !== 'schema') continue

          writer.indent(() => {
            for (const schemaChange of keywordChange.changes ?? []) {
              const prevSchemaComments = JSON.stringify(schemaChange.source || '', null, 2)
              const nextSchemaComments = JSON.stringify(schemaChange.target || '', null, 2)

              writer.writeLine(`- schema diff at "${schemaChange.jsonPath}":`)
              writer.indent(() => {
                prevSchemaComments.split('\n').forEach(l => writer.writeLine('- ' + l))
                nextSchemaComments.split('\n').forEach(l => writer.writeLine('+ ' + l))
                writer.blankLine()
              })
            }
          })
        }
      })
    }
  })

  writer.writeLine('*/')

  const fastifySchema = convertOpenApiToFastifyRouteSchema(routeDiff.sourceSchema)
  const serializedFastifySchema = inspect(
    fastifySchema ?? {},
    {
      depth: null,
      compact: false
    }
  )

  const routeHandler = await generateHandlerForChangedRoute(
    logger,
    method,
    openapiPath,
    prevVersionPrefix,
    nextVersionPrefix,
    routeDiff,
    userApiKey,
    openai,
    openaiProxyHost
  )

  const fastifyPath = convertOpenApiToFastifyPath(openapiPath)

  writer.write('fastify.route({').indent(() => {
    writer.writeLine(`method: '${method.toUpperCase()}',`)
    writer.writeLine(`url: '${fastifyPath}',`)
    writer.writeLine(`schema: ${serializedFastifySchema},`)
    writer.write(`handler: ${routeHandler}`)
  }).write('})')

  return writer.toString()
}

async function generateMapperPluginForDeletedRoute (
  logger,
  deletedRouteDiff,
  prevVersionConfig,
  nextVersionConfig
) {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  writer.writeLine('\'use strict\'')
  writer.blankLine()

  const method = deletedRouteDiff.method
  const openapiPath = deletedRouteDiff.path

  const routeMapper = await generateMapperForDeletedRoute(
    logger,
    method,
    openapiPath,
    prevVersionConfig,
    nextVersionConfig,
    deletedRouteDiff
  )

  writer.write('module.exports = async function (fastify, opts) {').indent(() => {
    writer.write(routeMapper)
  }).write('}\n')
  return writer.toString()
}

async function generateMapperPluginForChangesRoute (
  logger,
  changedRouteDiff,
  prevVersionConfig,
  nextVersionConfig,
  userApiKey,
  openai,
  openaiProxyHost
) {
  const writer = new CodeBlockWriter({
    newLine: '\n',
    indentNumberOfSpaces: 2,
    useTabs: false,
    useSingleQuote: true
  })

  writer.writeLine('\'use strict\'')
  writer.blankLine()

  const method = changedRouteDiff.method
  const openapiPath = changedRouteDiff.path

  const routeMapper = await generateMapperForChangedRoute(
    logger,
    method,
    openapiPath,
    prevVersionConfig,
    nextVersionConfig,
    changedRouteDiff,
    userApiKey,
    openai,
    openaiProxyHost
  )

  writer.write('module.exports = async function (fastify, opts) {').indent(() => {
    writer.write(routeMapper)
  }).write('}\n')
  return writer.toString()
}

function createProgressBar (count) {
  const multibar = new cliProgress.MultiBar({
    format: 'Routes generation: |' + green('{bar}') + '| {value}/{total} Generated routes | Time: {duration}s',
    clearOnComplete: true,
    stopOnComplete: true,
    gracefulExit: true
  }, cliProgress.Presets.shades_classic)

  const progressBar = multibar.create(count, 0)
  return {
    increment: () => progressBar.increment(),
    stop: () => {
      progressBar.stop()
      multibar.stop()
    }
  }
}

function generatePluginName (method, openapiPath) {
  const methodPrefix = method.toLowerCase()
  const pathPrefix = openapiPath
    .split('-')
    .map(p => p.replace(/\//g, '-'))
    .join('--')

  return methodPrefix + pathPrefix + '.js'
}

function generateOpenapiPath (pluginName) {
  const index = pluginName.indexOf('-')
  const methodPrefix = pluginName.slice(0, index)
  const pathPrefix = pluginName.slice(index + 1, -3)

  const method = methodPrefix.toLowerCase()

  // Should map "-" to "/" only if there is no another "-" next to it or before it
  const path = '/' + pathPrefix
    .split('--')
    .map(p => p.replace(/-/g, '/'))
    .join('-')

  return { method, path }
}

async function createMappersPlugins ({
  logger,
  configManager,
  prevVersion,
  nextVersion,
  prevOpenapiSchema,
  nextOpenapiSchema,
  userApiKey = null,
  openai = false,
  openaiProxyHost = OPENAI_SERVICE_HOST
}) {
  const config = configManager.current

  const versions = config.versions ?? {}
  const versionsConfigs = versions.configs ?? []

  const prevVersionConfig = versionsConfigs.find(c => c.version === prevVersion)
  const nextVersionConfig = versionsConfigs.find(c => c.version === nextVersion)

  const prevNormalizedOpenapiSchema = changeOpenapiSchemaPrefix(
    prevOpenapiSchema,
    prevVersionConfig.openapi.prefix,
    ''
  )

  const nextNormalizedOpenapiSchema = changeOpenapiSchemaPrefix(
    nextOpenapiSchema,
    nextVersionConfig.openapi.prefix,
    ''
  )

  const schemasDiff = compareOpenApiSchemas(
    prevNormalizedOpenapiSchema,
    nextNormalizedOpenapiSchema
  )

  const modifiedRoutesCount =
    schemasDiff.changedRoutes.length +
    schemasDiff.deletedRoutes.length

  if (modifiedRoutesCount === 0) {
    logger.info(
      `No changes found between "${prevVersion}" and "${nextVersion}" openapi schemas.` +
      ' Skipping mappers generation'
    )
    return null
  }

  logger.info(`Generating openapi mappers for "${prevVersion}" -> "${nextVersion}"`)

  const progressBar = createProgressBar(modifiedRoutesCount)
  const onRouteGenerated = async () => {
    progressBar.increment()
  }

  const mappersDir = join(versions.dir, prevVersionConfig.version, 'mappers')
  const mappersDirExists = await isFileAccessible(mappersDir)
  if (!mappersDirExists) {
    logger.info(`Creating mappers directory for "${prevVersion}" -> "${nextVersion}"`)
    await mkdir(mappersDir, { recursive: true })
  }

  const genPluginsReqs = []
  for (const deletedRouteDiff of schemasDiff.deletedRoutes) {
    const method = deletedRouteDiff.method
    const openapiPath = deletedRouteDiff.path

    const mapperPluginFileName = generatePluginName(method, openapiPath)
    const mapperPluginFilePath = join(mappersDir, mapperPluginFileName)

    const generateMapperReq = generateMapperPluginForDeletedRoute(
      logger,
      deletedRouteDiff,
      prevVersionConfig,
      nextVersionConfig
    )
      .then(
        async (mapperPlugin) => {
          await writeFile(mapperPluginFilePath, mapperPlugin, 'utf8')
        }
      )
      .then(
        async () => {
          await onRouteGenerated(method, openapiPath)
        }
      )

    genPluginsReqs.push(generateMapperReq)
  }

  for (const changedRouteDiff of schemasDiff.changedRoutes) {
    const method = changedRouteDiff.method
    const openapiPath = changedRouteDiff.path

    const mapperPluginFileName = generatePluginName(method, openapiPath)
    const mapperPluginFilePath = join(mappersDir, mapperPluginFileName)

    const generateMapperReq = generateMapperPluginForChangesRoute(
      logger,
      changedRouteDiff,
      prevVersionConfig,
      nextVersionConfig,
      userApiKey,
      openai,
      openaiProxyHost
    )
      .then(
        async (mapperPlugin) => {
          await writeFile(mapperPluginFilePath, mapperPlugin, 'utf8')
        }
      )
      .then(
        async () => {
          await onRouteGenerated(method, openapiPath)
        }
      )

    genPluginsReqs.push(generateMapperReq)
  }

  await Promise.all(genPluginsReqs)
  progressBar.stop()

  const mappersPluginsNames = await readdir(mappersDir)
  for (const mappersPluginName of mappersPluginsNames) {
    const { method, path } = generateOpenapiPath(mappersPluginName)

    const isDeletedRoute = schemasDiff.deletedRoutes.some(
      routeDiff => {
        return routeDiff.method === method && routeDiff.path === path
      }
    )
    const isChangedRoute = schemasDiff.changedRoutes.some(
      routeDiff => {
        return routeDiff.method === method && routeDiff.path === path
      }
    )
    if (!isDeletedRoute && !isChangedRoute) {
      logger.info(`Removing obsolete mappers plugin "${mappersPluginName}"`)
      const mapperPluginPath = join(mappersDir, mappersPluginName)
      await rm(mapperPluginPath, { force: true })
    }
  }

  logger.info(`Updating "${prevVersion}" version config with mappers plugin path`)
  await addMappersToConfig(mappersDir, prevVersionConfig.version, configManager)
}

async function addMappersToConfig (mappersDir, version, configManager) {
  const config = configManager.current
  const prevVersionConfig = config.versions.configs.find(c => c.version === version)

  const pluginsPaths = prevVersionConfig.plugins?.paths ?? []
  for (let foundPluginPath of pluginsPaths) {
    foundPluginPath = typeof foundPluginPath === 'string'
      ? foundPluginPath
      : foundPluginPath.path

    if (mappersDir.startsWith(foundPluginPath)) return
  }

  // TODO(mcollina) this must auto-upgrade
  const parse = getParser(configManager.fullPath)
  const stringify = getStringifier(configManager.fullPath)
  const rawConfig = parse(await readFile(configManager.fullPath, 'utf8'))
  const rawPrevVersionConfig = rawConfig.versions.configs.find(c => c.version === version)

  const relativePath = relative(configManager.dirname, mappersDir)
  if (!prevVersionConfig.plugins) {
    prevVersionConfig.plugins = { paths: [] }
    rawPrevVersionConfig.plugins = { paths: [] }
  }
  prevVersionConfig.plugins.paths.push(relativePath)
  rawPrevVersionConfig.plugins.paths.push(relativePath)
  await Promise.all([configManager.update(), writeFile(configManager.fullPath, stringify(rawConfig), 'utf8')])
}

async function execute ({
  logger,
  configManager,
  userApiKey,
  openai,
  openaiProxyHost
}) {
  const config = configManager.current

  const versions = config.versions ?? {}
  const versionsConfigs = versions.configs ?? []

  const nextVersionConfig = versionsConfigs.at(-1)
  if (!nextVersionConfig) {
    logger.info('No versions found. Skipping version update.')
    return
  }

  const nextVersion = nextVersionConfig.version
  const nextOpenapiSchemaPath = nextVersionConfig.openapi.path

  logger.info(`Loading openapi schema for "${nextVersion}"`)
  const nextOpenapiSchema = await getOpenapiSchema({
    logger,
    configManager,
    version: nextVersionConfig.version
  })
  logger.info(`Updating openapi schema for "${nextVersion}"`)
  await writeFile(nextOpenapiSchemaPath, JSON.stringify(nextOpenapiSchema, null, 2), 'utf8')

  const prevVersionConfig = versionsConfigs.at(-2)
  if (!prevVersionConfig) {
    logger.info('No previous versions found. Skipping mappers generation.')
    return
  }

  const prevVersion = prevVersionConfig.version
  const prevOpenapiSchemaPath = prevVersionConfig.openapi.path

  logger.info(`Reading openapi schema for "${prevVersion}"`)
  const prevOpenapiSchemaFile = await readFile(prevOpenapiSchemaPath, 'utf8')
  const prevOpenapiSchema = JSON.parse(prevOpenapiSchemaFile)

  await createMappersPlugins({
    logger,
    configManager,
    prevVersion,
    nextVersion,
    prevOpenapiSchema,
    nextOpenapiSchema,
    userApiKey,
    openai,
    openaiProxyHost
  })
}

async function updateVersion (_args) {
  const logger = pino(pretty({
    translateTime: 'SYS:HH:MM:ss',
    ignore: 'hostname,pid'
  }))

  try {
    const { configManager, args } = await loadConfig({
      string: ['openai-proxy-host', 'user-api-key'],
      boolean: ['openai']
    }, _args, platformaticService)
    await configManager.parseAndValidate()

    const openai = args.openai ?? false
    const openaiProxyHost = args['openai-proxy-host'] ?? OPENAI_SERVICE_HOST

    let userApiKey = args['user-api-key'] ?? null
    /* c8 ignore next 10 */
    if (!userApiKey && openai) {
      logger.info('Reading platformatic user api key')
      const { getUserApiKey } = await import('@platformatic/authenticate')
      try {
        userApiKey = await getUserApiKey()
      } catch (err) {
        logger.error('Failed to read user api key. Please run "plt login" command.')
        return
      }
    }

    await execute({
      logger,
      configManager,
      userApiKey,
      openai,
      openaiProxyHost
    })

    // TODO: find out why process stucks sometimes
    process.exit(0)
  } catch (err) {
    logger.error({ err })
    process.exit(1)
  }
}

module.exports = { execute, updateVersion, createMappersPlugins }
